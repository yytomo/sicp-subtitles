1
00:00:14,325 --> 00:00:17,723
Ich möchte Sie zu diesem Informatikkurs
willkommen heissen.

2
00:00:27,967 --> 00:00:29,782
Eigentlich ist das ein schlechter Anfang.

3
00:00:30,088 --> 00:00:31,922
Computerwissenschaft (computer science)
ist ein schrecklicher Name für dieses Geschäft.

4
00:00:32,288 --> 00:00:35,023
Erstens ist es keine Wissenschaft.

5
00:00:36,308 --> 00:00:39,341
Es könnte Ingenieurwesen (engineering) sein...
oder es könnte Kunst sein...

6
00:00:39,803 --> 00:00:41,597
Oder wir werden sogar sehen, dass Computer...

7
00:00:41,921 --> 00:00:44,700
sogenannte "Wissenschaft"
eigentlich viel mit Magie gemeinsam hat.

8
00:00:44,996 --> 00:00:46,287
Wir werden das in diesem Kurs sehen.

9
00:00:47,231 --> 00:00:52,370
Es ist also keine Wissenschaft. Es hat auch
nicht wirklich viel mit Computern zu tun.

10
00:00:53,589 --> 00:00:55,986
Und es geht nicht über Computer
in dem gleichen Sinn wie es...

11
00:00:56,543 --> 00:01:00,016
in Physik nicht wirklich
um Teilchenbeschleuniger...

12
00:01:00,372 --> 00:01:05,465
und Biologie nicht wirklich
um Mikroskope und Petrischalen geht.

13
00:01:05,993 --> 00:01:11,208
Und es geht nicht um Computer
in dem selben Sinn wie es in Geometrie

14
00:01:11,631 --> 00:01:15,210
nicht wirklich um das Benutzen
von Messinstrumenten geht.

15
00:01:16,225 --> 00:01:20,680
Tatsächlich gibt es viele Gemeinsamkeiten
zwischen Informatik und Geometrie.

16
00:01:21,081 --> 00:01:25,063
Geometrie ist erst einmal noch ein Fach
mit einem schlechten Namen.

17
00:01:25,794 --> 00:01:29,206
Der Name kommt von "Gaia", das heisst die Erde
und "Metron", das heisst messen.

18
00:01:29,722 --> 00:01:33,237
Geometrie hat ursprünglich bedeutet,
die Erde zu messen... oder zu begutachten.

19
00:01:34,231 --> 00:01:36,915
Und der Grund dafür war,
dass vor Tausenden von Jahren

20
00:01:37,518 --> 00:01:41,684
die ägyptische Priesterschaft
Ansätze der Geometrie entwickelt hat,

21
00:01:42,348 --> 00:01:44,706
um herauszufinden, wie man die Felderbegrenzungen, 

22
00:01:45,228 --> 00:01:48,367
die bei der jährlichen Überflutung des Nils
zerstört wurden, wiederherstellen kann.

23
00:01:49,014 --> 00:01:51,764
Und für die Ägypter die das gemacht haben,
war Geometrie wirklich

24
00:01:52,186 --> 00:01:53,880
das Benutzen von Messgeräten.

25
00:01:55,529 --> 00:01:58,322
Nun, der Grund dass wir denken, dass
es in der Informatik um Computer geht

26
00:01:58,669 --> 00:02:00,424
ist so ziemlich der gleiche Grund

27
00:02:00,983 --> 00:02:03,743
warum die Ägypter dachten,
dass Geometrie über Messgeräte geht.

28
00:02:04,399 --> 00:02:05,623
Und das passiert, wenn

29
00:02:06,009 --> 00:02:09,715
ein Gebiet gerade anfängt, und man es
noch nicht wirklich sehr gut versteht.

30
00:02:11,023 --> 00:02:14,079
Es ist sehr einfach, den Kern
von dem was man tut,

31
00:02:14,660 --> 00:02:16,068
mit den Geräten, die man verwendet, zu verwechseln.

32
00:02:17,216 --> 00:02:21,796
Und tatsächlich, auf einer absoluten
Skala wissen wir wahrscheinlich weniger

33
00:02:22,269 --> 00:02:24,486
über die Essenz der Informatik

34
00:02:24,943 --> 00:02:27,376
als die alten Ägypter wirklich
über Geometrie gewusst haben.

35
00:02:29,675 --> 00:02:32,248
So, was ich meine mit
der Essenz der Informatik,

36
00:02:32,549 --> 00:02:33,549
was ich meine mit der Essenz der Geometrie,...

37
00:02:34,066 --> 00:02:37,367
Sehen Sie, es ist sicherlich wahr, dass diese
Ägypter oft Messinstrumente verwendet haben.

38
00:02:37,761 --> 00:02:39,390
Aber wenn wir auf sie zurücksehen,

39
00:02:40,072 --> 00:02:42,820
nach ein paar tausend Jahren sagen wir,
"Meine Güte! Was haben die gemacht?"

40
00:02:43,556 --> 00:02:47,475
Das wichtige an dem, was sie gemacht haben,
war anzufangen, Begriffe

41
00:02:48,141 --> 00:02:50,993
von Raum und Zeit zu formalisieren.

42
00:02:51,328 --> 00:02:55,031
Ein Mittel, formal über mathematische Wahrheit

43
00:02:55,574 --> 00:03:00,062
zu sprechen, die zur axiomatischen
Methode führte, die zu...

44
00:03:00,646 --> 00:03:02,505
so ziemlich aller moderner Mathematik führte.

45
00:03:04,055 --> 00:03:08,735
Sich einen Weg auzudenken, genau über
sogenanntes "deklaratives" Wissen zu sprechen -

46
00:03:09,164 --> 00:03:11,191
"was wahr ist".

47
00:03:12,514 --> 00:03:15,842
Nun, ähnlich, denke ich, werden in der Zukunft
Leute zurücksehen und sagen,

48
00:03:16,243 --> 00:03:18,235
ja, diese Primitiven
im zwanzigsten Jahrhundert

49
00:03:18,537 --> 00:03:20,979
haben mit diesen Computer-Apparaten herumgespielt,

50
00:03:21,527 --> 00:03:23,332
aber eigentlich, was sie gemacht haben

51
00:03:23,746 --> 00:03:27,333
ist beginnen zu lernen, wie man formalisiert,

52
00:03:28,815 --> 00:03:32,026
Intuitionen formalisiert über... Prozesse,...

53
00:03:32,461 --> 00:03:34,069
wie man Sachen macht.

54
00:03:39,360 --> 00:03:48,073
Anzufangen einen Weg zu entwickeln...

55
00:03:48,555 --> 00:03:51,305
präzise über "wie man"-Wissen zu sprechen,

56
00:03:51,741 --> 00:03:56,100
im Gegensatz zur Geometrie,
die darüber redet, "was wahr ist".

57
00:03:56,569 --> 00:03:58,498
Lassen Sie mich ein Beispiel davon geben.

58
00:04:01,893 --> 00:04:06,554
Schauen wir mal... Hier ist
ein Teil... ein Teil Mathematik.

59
00:04:06,972 --> 00:04:09,506
Oder? Das sagt, was eine Quadratwurzel ist.

60
00:04:10,133 --> 00:04:14,359
Die Quadratwurzel aus X ist die Zahl Y,

61
00:04:14,768 --> 00:04:17,972
so dass Y quadriert gleich X ist,

62
00:04:18,373 --> 00:04:20,091
und Y größer als Null ist.

63
00:04:20,469 --> 00:04:22,040
Also das ist ein schönes Teil Mathematik,

64
00:04:22,667 --> 00:04:27,369
aber Ihnen nur zu sagen, was eine Quadratwurzel
ist, sagt nicht wirklich etwas aus über...

65
00:04:28,086 --> 00:04:30,508
darüber, wie Sie herangehen
und eine finden könnten.

66
00:04:31,093 --> 00:04:35,758
Lassen Sie uns das von einem Teil
imperativen Wissens unterscheiden.

67
00:04:37,002 --> 00:04:39,559
Oder? Wie Sie herangehen und
die Quadratwurzel finden könnten.

68
00:04:39,901 --> 00:04:45,300
Das kommt in der Tat auch aus Ägypten.
Nicht dem uralten Ägypten.

69
00:04:45,701 --> 00:04:48,563
Das ist ein Algorithmus,
der von Heron von Alexandria stammt,

70
00:04:50,067 --> 00:04:52,526
genannt, wie man eine Quadratwurzel findet
durch aufeinanderfolgendes Mitteln.

71
00:04:52,927 --> 00:04:54,248
Und was er aussagt ist...

72
00:04:54,661 --> 00:04:57,669
daß, um eine Quadratwurzel zu finden...

73
00:05:01,740 --> 00:05:04,970
um eine Quadratwurzel zu finden,
macht man eine Schätzung,

74
00:05:05,983 --> 00:05:08,112
man verbessert diese Schätzung,

75
00:05:09,495 --> 00:05:13,563
und die Schätzung verbessert man durch Mitteln der
Schätzung und X geteilt durch die Schätzung.

76
00:05:14,056 --> 00:05:16,864
Wir werden ein bisschen später darüber
reden, warum das vernünftig ist.

77
00:05:17,196 --> 00:05:19,210
Und man verbessert die Schätzung
immer weiter bis sie gut genug ist.

78
00:05:19,767 --> 00:05:23,168
Das ist eine Methode.
Das ist, wie man etwas macht.

79
00:05:23,694 --> 00:05:27,485
Im Unterschied zu deklarativem Wissen,
das aussagt, wonach man sucht.

80
00:05:28,080 --> 00:05:30,942
Und das ist ein Prozess.

81
00:05:34,275 --> 00:05:38,350
Naja, was ist ein Prozess allgemein?

82
00:05:38,784 --> 00:05:43,844
Es ist ziemlich schwer zu sagen. Man kann es
sich vorstellen wie einen magischen Geist

83
00:05:44,625 --> 00:05:47,432
der sozusagen im Computer lebt und etwas tut.

84
00:05:47,849 --> 00:05:49,381
Und...

85
00:05:52,169 --> 00:05:58,065
Das Ding, das einen Prozess anweist, ist
ein Muster aus Regeln, genannt Prozedur.

86
00:06:01,715 --> 00:06:04,544
Also Prozeduren sind die Sprüche, wenn Sie wollen,

87
00:06:04,940 --> 00:06:09,349
die die magischen Geister kontrollieren,
die die Prozesse sind.

88
00:06:09,749 --> 00:06:12,331
Und... also ich denke Sie wissen, dass
jeder eine magische Sprache braucht.

89
00:06:12,732 --> 00:06:15,712
Und Zauberer, oder?,
echte Zauberer verwenden altes Arkadisch,

90
00:06:16,311 --> 00:06:17,513
oder Sumerisch, oder Babylonisch oder was auch immer.

91
00:06:18,844 --> 00:06:23,275
Wir werden unsere Geister in einer
magischen Sprache namens LISP beschwören,

92
00:06:24,394 --> 00:06:28,043
Das ist eine Sprache, die
entworfen wurde, um über...

93
00:06:28,508 --> 00:06:31,703
um die Sprüche zu wirken, die Prozeduren sind,
um die Prozesse anzuleiten.

94
00:06:32,232 --> 00:06:33,440
Nun,
es ist sehr einfach LISP zu lernen.

95
00:06:33,775 --> 00:06:36,837
Tatsächlich werde ich Ihnen in ein paar Minuten
im Wesentilichen alles über LISP beibringen.

96
00:06:37,196 --> 00:06:39,491
Ich werde Ihnen im Wesentlichen
alle Regeln beibringen...

97
00:06:40,425 --> 00:06:43,016
Und Sie sollten das nicht
besonders überraschend finden.

98
00:06:43,451 --> 00:06:46,522
Das ist sozusagen wie zu sagen, es ist sehr 
einfach, die Schachregeln zu lernen.

99
00:06:46,923 --> 00:06:49,721
Und tatsächlich kann man in ein paar Minuten
jemandem die Schachregeln sagen,

100
00:06:50,558 --> 00:06:52,736
aber natürlich ist das
sehr unterschiedlich davon, zu sagen,

101
00:06:53,283 --> 00:06:55,146
dass man die Implikationen
dieser Regeln versteht

102
00:06:55,381 --> 00:06:58,038
und wie man diese Regeln einsetzt,
um ein meisterhafter Schachspieler zu werden.

103
00:06:58,452 --> 00:06:59,880
Naja, LISP ist genauso.

104
00:07:00,236 --> 00:07:03,118
Wir werden die Regeln in ein paar Minuten aufstellen
und sie werden sehr einfach einzusehen sein,

105
00:07:03,519 --> 00:07:06,899
aber was wirklich schwer sein wird,
sind die Implikationen dieser Regeln.

106
00:07:07,402 --> 00:07:10,699
Wie man diese Regeln ausnutzt,
um ein Meisterprogrammierer zu sein.

107
00:07:12,032 --> 00:07:15,452
Und für die Implikationen
dieser Regeln werden wir den...

108
00:07:16,053 --> 00:07:19,137
naja, den ganzen Rest dieses Themas,
und natürlich weit darüber hinaus brauchen.

109
00:07:21,457 --> 00:07:23,553
OK. Also, in der Informatik

110
00:07:24,462 --> 00:07:30,347
sind wir beim Geschäft, sozusagen das
"wie man" imperative Wissen zu formalisieren.

111
00:07:30,768 --> 00:07:32,430
Richtig? Wie man etwas macht.

112
00:07:33,155 --> 00:07:35,653
Und die echten Aufgaben der Informatik
sind natürlich nicht,

113
00:07:35,987 --> 00:07:38,092
wie Sie wissen, Leuten zu erzählen,
wie man Quadratwurzeln zieht.

114
00:07:38,734 --> 00:07:41,242
Denn wenn das Alles wäre,
wäre es keine große Sache.

115
00:07:41,609 --> 00:07:46,100
Die echten Probleme kommen, wenn wir
sehr sehr große Systeme bauen wollen.

116
00:07:46,572 --> 00:07:49,279
Oder? Computerprogramme,
die tausende Seiten lang sind.

117
00:07:49,610 --> 00:07:53,302
So lang, dass sie niemand gleichzeitig
wirklich ganz in seinem Kopf behalten kann.

118
00:07:53,719 --> 00:08:00,191
Und der einzige Grund, dass das möglich ist,
ist, weil es Verfahren gibt...

119
00:08:01,388 --> 00:08:04,219
es gibt Verfahren...

120
00:08:06,113 --> 00:08:14,423
die Komplexität zu kontrollieren...

121
00:08:17,565 --> 00:08:19,613
von diesen großen Systemen.

122
00:08:20,148 --> 00:08:21,353
Und diese Verfahren,

123
00:08:21,697 --> 00:08:24,261
die Komplexität zu kontrollieren,
sind, worüber dieser Kurs eigentlich ist.

124
00:08:24,656 --> 00:08:28,062
Und in einem bestimmten Sinn ist es das,
worum es bei Informatik geht.

125
00:08:29,540 --> 00:08:31,459
Das mag jetzt wie eine
merkwürdige Aussage erscheinen,

126
00:08:31,794 --> 00:08:33,628
weil immerhin viele Leute

127
00:08:34,132 --> 00:08:37,643
außer Informatikern
mit dem Beherrschen von Komplexität umgehen.

128
00:08:38,033 --> 00:08:41,010
Ein großes Verkehrsflugzeug
ist ein extrem komplexes System.

129
00:08:41,694 --> 00:08:43,714
Und die Luftfahrtsingenieure,
die das Flugzeug entwerfen,

130
00:08:44,131 --> 00:08:46,005
wie Sie wissen,
werden mit der immensen Komplexität fertig.

131
00:08:46,937 --> 00:08:48,134
Aber es gibt einen Unterschied

132
00:08:48,564 --> 00:08:52,986
zwischen dieser Art Komplexität und
womit wir in der Informatik umgehen.

133
00:08:54,900 --> 00:09:00,112
Und der ist, dass Informatik
in einem bestimmten Sinn nicht real ist.

134
00:09:02,550 --> 00:09:06,548
Sehen Sie, wenn ein Ingenieur
ein physikalisches System entwirft,

135
00:09:06,969 --> 00:09:10,980
das aus echten Teilen gemacht ist, richtig?,
die Ingenieure, die sich darüber Gedanken machen,

136
00:09:11,663 --> 00:09:16,223
müssen Toleranzprobleme angehen und
Annäherung und Störung im System.

137
00:09:16,624 --> 00:09:19,913
Also zum Beispiel, als ein Elektroingenieur
kann ich hingehen und leicht

138
00:09:20,239 --> 00:09:22,849
einen einstufigen Verstärker oder
einen zweistufigen Verstärker bauen.

139
00:09:23,283 --> 00:09:26,552
Und mir vorstellen, viele davon hintereinanderzuschalten
und einen millionenstufigen Verstärker zu bauen.

140
00:09:26,974 --> 00:09:29,412
Aber es ist lächerlich,
so ein Ding zu bauen, weil

141
00:09:29,747 --> 00:09:31,712
lange vor der millionsten Stufe wird

142
00:09:32,113 --> 00:09:35,152
das thermische Rauschen ganz am Anfang
in diesen Komponenten verstärkt sein,

143
00:09:35,459 --> 00:09:37,375
und das ganze Teil bedeutungslos gemacht haben.

144
00:09:38,827 --> 00:09:42,950
Informatrk beschäftigt sich
mit idealisierten Komponenten.

145
00:09:43,867 --> 00:09:47,808
Wir wissen soviel wir wollen
über diese kleine Programmdatenteile,

146
00:09:48,204 --> 00:09:49,369
um die Sachen passend zu machen.

147
00:09:50,356 --> 00:09:54,099
Richtig? Also... Wir müssen uns nicht über
Toleranz Gedanken machen und das bedeutet,

148
00:09:55,255 --> 00:09:59,845
dass es beim Bauen eines großen Programms
keinen großen Unterschied gibt zwischen dem,

149
00:10:00,343 --> 00:10:04,586
was ich bauen kann, und dem,
was ich mir vorstellen kann.

150
00:10:05,367 --> 00:10:09,741
Denn über die Teile dieser abstrakten Gebilde
weiß ich so viel ich will.

151
00:10:10,142 --> 00:10:12,553
Ich weiss Bescheid über sie,
so genau wie ich möchte.

152
00:10:13,227 --> 00:10:15,269
Also, im Unterschied zu
anderen Arten des Ingenieurswesens,

153
00:10:15,667 --> 00:10:17,453
wo die Beschränkungen, was man
bauen kann, die Beschränkungen der

154
00:10:17,839 --> 00:10:20,882
physikalischen Systeme, die Beschränkungen der
Physik und Störung und Näherung sind.

155
00:10:21,277 --> 00:10:23,324
Die auferlegten Beschränkungen...

156
00:10:24,012 --> 00:10:28,107
sind beim Bauen von großen Softwaresystemen
die Schranken unseres eigenen Geistes.

157
00:10:28,834 --> 00:10:33,462
Also in diesem Sinn ist Informatik
wie eine abstrakte Form des Ingenieurswesens.

158
00:10:33,796 --> 00:10:36,146
Es ist die Art von Ingenieurwesen,
wo man die Beschränkungen ignoriert,

159
00:10:36,642 --> 00:10:38,594
die von der Realität auferlegt sind.

160
00:10:41,593 --> 00:10:45,766
OK. Nun, was sind...
Was sind einige dieser Verfahren?

161
00:10:46,343 --> 00:10:49,097
Sie sind nicht für die Informatik speziell.

162
00:10:50,216 --> 00:10:55,508
Das erste Verfahren, das in jedem Ingenieurswesen
verwendet wird, ist eine Art Abstraktion

163
00:10:56,474 --> 00:11:00,779
namens Black-Box Abstraktion.
(schwarzer Kasten)

164
00:11:06,863 --> 00:11:12,934
Nimm etwas und baue einen Kasten darum.

165
00:11:14,087 --> 00:11:20,634
Sehen Sie, zum Beispiel, wenn wir uns
diese Quadratwurzelmethode ansehen würden,

166
00:11:22,503 --> 00:11:26,091
könnte ich das nehmen wollen und...

167
00:11:27,136 --> 00:11:30,256
eine Box bauen, die in etwa heisst:

168
00:11:30,656 --> 00:11:37,771
"um eine Quadratwurzel von X zu finden".

169
00:11:38,506 --> 00:11:41,651
Jetzt könnte das
eine ganz komplizierte Menge an Regeln sein,

170
00:11:42,353 --> 00:11:48,017
und das könnte auf eine Art Ding hinauslaufen,
wo ich, sagen wir, 36 eingebe und sage,

171
00:11:48,518 --> 00:11:52,332
was ist die Quadratwurzel von 36,
und raus kommt 6.

172
00:11:53,877 --> 00:11:57,577
Und das Wichtige ist,
dass ich das so entwerfen möchte,

173
00:11:58,309 --> 00:12:07,829
so dass wenn Georg vorbei kommt und
die Quadratwurzel von A plus
die Quadratwurzel von B berechnen möchte,

174
00:12:08,348 --> 00:12:13,992
kann er dieses Teil nehmen
und es als Modul verwenden,

175
00:12:14,355 --> 00:12:17,259
ohne hineinschauen zu müssen und
etwas bauen, das so aussieht:

176
00:12:18,252 --> 00:12:26,350
ein A und B, und eine Quadratwurzelbox,
und eine andere Quadratwurzelbox,

177
00:12:29,610 --> 00:12:31,760
und dann etwas das addiert.

178
00:12:32,293 --> 00:12:37,690
Das würde jetzt eine Antwort ausgeben.
Und Sie können sehen, ich will das nur deswegen machen,

179
00:12:38,091 --> 00:12:41,499
weil aus Georgs Sichtweise
das Innenleben davon, was hier drin ist,

180
00:12:41,900 --> 00:12:45,508
nicht wichtig sein sollte.
Also zum Beispiel, es sollte nichts ausmachen, dass,

181
00:12:45,841 --> 00:12:50,175
als ich das geschrieben habe, sagte ich,
ich will die Quadratwurzel von X finden.

182
00:12:50,523 --> 00:12:53,835
Ich hätte sagen können die Quadratwurzel von Y.
Oder die Quadratwurzel von A.

183
00:12:54,190 --> 00:12:58,068
Oder überhaupt irgendwas.
Und das ist die grundlegende Idee,

184
00:12:58,566 --> 00:13:02,085
etwas in eine Box zu stecken....

185
00:13:03,435 --> 00:13:06,751
Black-Box Abstraktion zu verwenden,
um Detail zu verbergen.

186
00:13:07,370 --> 00:13:11,130
Und der Grund dafür ist, dass Sie
hergehen wollen und größere Boxen bauen wollen.

187
00:13:11,960 --> 00:13:14,215
Nun, es gibt einen anderen Grund
für Black-Box Abstraktion.

188
00:13:14,529 --> 00:13:18,047
Außer dem, Details verbergen zu wollen,
um größere Boxen zu bauen.

189
00:13:18,448 --> 00:13:26,131
Manchmal will man sagen, die Art etwas
zu tun, die "wie man"-Methode

190
00:13:27,907 --> 00:13:30,513
ist eine Instanz von etwas Allgemeinerem.

191
00:13:30,946 --> 00:13:34,732
Und man möchte, dass die Sprache
diese Allgemeingültigkeit ausdrücken kann.

192
00:13:35,248 --> 00:13:39,462
Lassen Sie mich ein anderes Beispiel zeigen,
wieder bei der Quadratwurzel. Gehen wir zurück

193
00:13:39,863 --> 00:13:43,978
und sehen nochmal die Folie
mit dem Quadratwurzelalgorithmus darauf an.

194
00:13:44,436 --> 00:13:50,042
Erinnern Sie sich, was er aussagt? Er sagt aus,
um etwas zu tun, werde ich schätzen (guess),

195
00:13:50,590 --> 00:13:54,989
und ich werde diese Schätzung verbessern (improve),
und ich verbessere diese Schätzung immer mehr.

196
00:13:55,788 --> 00:14:00,416
Also, es gibt eine allgemeine Strategie,
nach etwas zu suchen.

197
00:14:01,189 --> 00:14:03,770
Und der Weg wie ich es finde, ist,
dass ich es immer weiter verbessere.

198
00:14:04,171 --> 00:14:10,379
Jetzt ist das ein besonderer Fall
einer anderen Art von Strategie

199
00:14:10,984 --> 00:14:12,896
einen Fixpunkt von etwas zu finden.

200
00:14:14,466 --> 00:14:21,192
Um einen Fixpunkt einer Funktion zu haben...
Ein Fixpunkt... einer Funktion...

201
00:14:22,417 --> 00:14:28,138
ist etwas... ist ein Wert...
Der Fixpunkt einer Funktion F ist ein Wert Y, so dass

202
00:14:28,539 --> 00:14:32,030
F von Y gleich Y ist.

203
00:14:32,986 --> 00:14:35,680
Und wie ich das tun könnte...

204
00:14:38,690 --> 00:14:44,076
ist mit einer Schätzung anzufangen,
und wenn ich etwas will, das sich nicht ändert,

205
00:14:44,477 --> 00:14:47,103
wenn ich F immer weiter anwende, ist,
dass ich F immer wieder und wieder anwende,

206
00:14:47,603 --> 00:14:51,730
bis sich das Ergebnis nicht mehr viel
ändert. Also es gibt eine allgemeine Strategie,

207
00:14:52,238 --> 00:14:55,858
und dann zum Beispiel,
um die Quadratwurzel (sqrt) von X zu berechnen,

208
00:14:56,263 --> 00:14:57,622
kann ich ausprobieren,

209
00:14:58,565 --> 00:15:03,041
einen Fixpunkt der Funktion zu finden,
die Y zum Mittel von X geteilt durch Y gehen lässt.

210
00:15:03,388 --> 00:15:07,568
Und die Idee davon ist, dass, wenn wirklich
Y gleich der Quadratwurzel von X wäre,

211
00:15:08,116 --> 00:15:11,619
dann hätten Y und X geteilt durch Y denselben Wert.

212
00:15:12,077 --> 00:15:13,532
Sie wären beide die Quadratwurzel von X.

213
00:15:13,997 --> 00:15:18,732
Oder? Denn X geteilt durch die Quadratwurzel von X
ist die Quadratwurzel von X.

214
00:15:19,106 --> 00:15:21,805
Und so würde sich das Mittel, wenn Y gleich
der Quadratwurzel von X wäre,

215
00:15:22,283 --> 00:15:25,612
dann würde sich das Mittel nicht mehr ändern.

216
00:15:26,019 --> 00:15:29,001
Also ist die Quadratwurzel von X ein Fixpunkt
dieser speziellen Funktion.

217
00:15:30,079 --> 00:15:34,778
Nun, was Ich gerne haben möchte...
Ich möchte die allgemeine Strategie darstellen,

218
00:15:35,179 --> 00:15:40,497
um Fixpunkte zu finden. Also was ich mir vorstellen
könnte zu tun, ist etwas zu finden...

219
00:15:40,970 --> 00:15:47,816
ist meine Sprache verwenden zu können,
um eine Box zu definieren, die sagt, finde einen Fixpunkt.

220
00:15:49,468 --> 00:15:52,312
Genauso wie ich eine Box machen könnte,
die aussagt Quadratwurzel,

221
00:15:52,712 --> 00:15:55,617
und ich möchte das in meiner Sprache ausdrücken können.

222
00:15:56,142 --> 00:15:59,480
Also ich möchte nicht nur
das imperative "wie man" Wissen

223
00:15:59,981 --> 00:16:04,212
über was Spezielles wie die Quadratwurzel ausdrücken können,
sondern ich möchte das imperative Wissen ausdrücken können,

224
00:16:04,613 --> 00:16:08,704
wie man etwas Allgemeines machen kann,
wie man einen Fixpunkt findet.

225
00:16:09,821 --> 00:16:13,493
Und gehen wir tatsächlich zurück,
und sehen diese Folie nochmal an.

226
00:16:14,896 --> 00:16:17,095
Sehen Sie, nicht nur ist...

227
00:16:21,467 --> 00:16:25,396
ist das ein Teil imperatives Wissen,
wie man einen Fixpunkt findet,

228
00:16:26,070 --> 00:16:29,215
sondern hier unten ist ein anderes
Teil imperativen Wissens,

229
00:16:29,706 --> 00:16:32,616
das beschreibt,
ein Weg eine Quadratwurzel zu berechnen, ist,

230
00:16:33,224 --> 00:16:35,833
diese allgemeine Fixpunktmethode anzuwenden.

231
00:16:36,191 --> 00:16:39,283
Also möchte ich auch dieses imperative
Wissen ausdrücken können.

232
00:16:39,685 --> 00:16:45,157
Wie würde das aussehen? Das würde heissen,
diese Fixpunktbox ist so, dass

233
00:16:45,650 --> 00:16:58,622
wenn ich in sie die Funktion eingebe, die
Y zum Mittel von Y und X/Y gehen lässt,

234
00:16:59,491 --> 00:17:03,367
dann, was aus dieser Fixpunktbox
kommen sollte ist...

235
00:17:04,211 --> 00:17:07,420
eine Methode, um Quadratwurzeln zu finden.

236
00:17:08,642 --> 00:17:11,835
Also in diesen Boxen bauen wir...
Wir bauen nicht nur Boxen,

237
00:17:12,236 --> 00:17:15,405
in die man Zahlen eingibt und die Zahlen ausgeben.

238
00:17:16,338 --> 00:17:19,568
Wir werden Boxen bauen,
die als Ergebnis Methoden berechnen

239
00:17:19,869 --> 00:17:21,266
wie Quadratwurzelziehen.

240
00:17:21,975 --> 00:17:25,943
Und sie könnten als Eingabe Funktionen nehmen, wie

241
00:17:26,415 --> 00:17:29,299
Y geht gegen das Mittel von Y und X/Y.

242
00:17:29,782 --> 00:17:32,608
Der Grund warum wir das machen wollen...
sehen Sie, der Grund...

243
00:17:33,009 --> 00:17:35,951
Das ist eine Prozedur oder wird eine
Prozedur, wie wir sehen werden,

244
00:17:36,352 --> 00:17:41,006
wessen Wert eine andere Prozedur ist.
Der Grund warum wir das machen wollen, ist,

245
00:17:41,307 --> 00:17:47,039
weil Prozeduren unser Weg sein werden,
über imperatives Wissen zu sprechen.

246
00:17:47,952 --> 00:17:49,292
Und wie das sehr mächtig werden kann, ist,

247
00:17:49,677 --> 00:17:52,348
über andere Arten von Wissen
sprechen zu können.

248
00:17:53,249 --> 00:17:56,545
Also, hier ist eine Prozedur, die tatsächlich
über eine andere Prozedur spricht.

249
00:17:56,946 --> 00:18:00,888
Und die allgemeine Strategie, die selbst
über allgemeine Strategien spricht.

250
00:18:03,504 --> 00:18:09,196
OK. Nun, unser erstes Thema in diesem Kurs
(es wird drei größere Themen geben)

251
00:18:09,597 --> 00:18:13,749
wird Black-Box Abstraktion sein. Sehen wir
uns das ein wenig genauer an.

252
00:18:14,962 --> 00:18:20,629
Naja, was wir machen werden, ist, wir werden...

253
00:18:21,744 --> 00:18:26,857
Wir werden anfangen darüber zu sprechen,
wie LISP aufgebaut ist aus primitiven Objekten,

254
00:18:27,200 --> 00:18:29,227
was uns die Sprache mitgibt.

255
00:18:29,647 --> 00:18:34,152
Und wir werden feststellen, dass es
primitive Prozeduren und primitive Daten gibt.

256
00:18:35,310 --> 00:18:38,214
Dann werden wir sehen,
wie man diese Primitiven nimmt

257
00:18:38,515 --> 00:18:40,905
und sie kombiniert,
um kompliziertere Dinge zu bauen.

258
00:18:41,406 --> 00:18:42,886
Mittel der Kombination.

259
00:18:43,215 --> 00:18:46,169
Und wir werden feststellen, dass es
Möglichkeiten gibt, Dinge zusammenzubauen,

260
00:18:46,470 --> 00:18:50,672
primitive Prozeduren zusammenzubauen,
um kompliziertere Prozeduren zu machen.

261
00:18:50,867 --> 00:18:55,349
Und wir werden sehen, wie man primitive Daten
zusammenbaut um zusammengesetzte Daten zu machen.

262
00:18:55,758 --> 00:19:00,407
Dann werden wir sagen: Nun, nachdem wir
diese zusammengesetzten Dinge gemacht haben,

263
00:19:00,708 --> 00:19:02,189
wie kann man sie abstrahieren?

264
00:19:02,795 --> 00:19:04,912
Wie kann man diese schwarzen
Boxen um sie stellen,

265
00:19:05,213 --> 00:19:07,711
so dass man sie als Komponenten
in komplexeren Dingen verwenden kann?

266
00:19:08,017 --> 00:19:11,225
Und wir werden sehen,
das wird gemacht mit Definieren von Prozeduren und

267
00:19:11,649 --> 00:19:15,152
mit einer Methode, mit zusammengesetzten Daten
zu hantieren, genannt Datenabstraktion.

268
00:19:15,522 --> 00:19:18,681
Und dann,
was vielleicht das Wichtigste ist, ist,

269
00:19:19,016 --> 00:19:21,517
wie kommt man nur von den Regeln dazu,
wie ein Experte arbeitet.

270
00:19:21,818 --> 00:19:26,298
Wie drückt man gemeinsame Muster,
Dinge zu tun, aus, wie zu sagen,

271
00:19:26,599 --> 00:19:28,463
also, es gibt eine
allgemeine Methode des Fixpunkts,

272
00:19:28,764 --> 00:19:31,738
und Quadratwurzel
ist ein Spezialfall davon.

273
00:19:32,023 --> 00:19:34,200
Und wir werden verwenden...

274
00:19:34,501 --> 00:19:37,627
Ich habe bereits darauf hingewiesen, dass es etwas
namens Prozeduren höherer Ordnung ist,

275
00:19:37,928 --> 00:19:42,765
nämlich Prozeduren, deren Eingaben
und Ausgaben selbst Prozeduren sind.

276
00:19:43,200 --> 00:19:45,455
Und wir werden auch
etwas sehr Interessantes feststellen,

277
00:19:45,772 --> 00:19:48,272
während wir weiter und weiter gehen
und abstrakter werden

278
00:19:48,746 --> 00:19:49,763
es wird sehr...

279
00:19:50,064 --> 00:19:53,096
nun ja, die Grenze zwischen dem,
was wir für Daten und dem,

280
00:19:53,447 --> 00:19:58,763
was wir für Prozeduren halten,
wird unglaublich schnell verschwimmen.

281
00:20:02,561 --> 00:20:06,843
Richtig, also das ist unser erstes Thema,
Black-Box Abstraktion.

282
00:20:07,144 --> 00:20:08,675
Sehen wir uns das zweite Thema an.

283
00:20:10,840 --> 00:20:12,787
Ich kann es einleiten...

284
00:20:13,084 --> 00:20:18,731
Schauen wir mal, so.
Angenommen, ich will die Idee ausdrücken...

285
00:20:19,441 --> 00:20:22,564
Erinnern Sie sich, wir sprechen über Ideen.

286
00:20:22,826 --> 00:20:25,773
Angenommen, ich will die Idee ausdrücken, dass

287
00:20:26,379 --> 00:20:28,981
ich etwas nehmen kann

288
00:20:30,390 --> 00:20:34,897
und es mit der Summe von
zwei anderen Dingen multiplizieren kann.

289
00:20:35,830 --> 00:20:37,784
Also zum Beispiel könnte ich sagen,

290
00:20:38,185 --> 00:20:41,579
wenn ich 1 und 3 addiere,
und das mit 2 multipliziere, bekomme ich 8.

291
00:20:41,880 --> 00:20:44,916
Aber ich spreche über die allgemeine Idee,
die Linearkombination genannt wird.

292
00:20:45,286 --> 00:20:48,801
Dass man zwei Dinge addieren
und mit etwas anderem multiplizieren kann.

293
00:20:49,149 --> 00:20:51,919
Es ist sehr einfach, wenn ich darüber
mit Zahlen denke, aber angenommen ich...

294
00:20:52,280 --> 00:20:55,661
Ich will sogar dieselbe Idee verwenden,
um nachzudenken über...

295
00:20:55,962 --> 00:20:58,712
Ich könnte zwei Vektoren a1 und a2 addieren,

296
00:20:59,535 --> 00:21:02,758
und sie dann skalieren mit einem Faktor x
und einen anderen Vektor bekommen.

297
00:21:03,059 --> 00:21:09,736
Oder ich könnte sagen, ich will
über a1 und a2 als Polynomiale denken.

298
00:21:10,525 --> 00:21:12,906
Und ich könnte
diese zwei Polinomiale addieren wollen

299
00:21:13,207 --> 00:21:17,104
und dann mit zwei multiplizieren,
um ein komplizierteres zu bekommen.

300
00:21:20,116 --> 00:21:24,079
Oder a1 und a2 könnten elektrische Signale sein,

301
00:21:24,455 --> 00:21:27,086
und ich könnte beabsichtigen,
diese zwei elektrischen Signale zu summieren,

302
00:21:27,428 --> 00:21:30,767
und dann das ganze Teil an einen
Verstärker leiten und es mit

303
00:21:31,168 --> 00:21:33,252
einem Faktor zwei oder so multiplizieren.

304
00:21:33,693 --> 00:21:37,463
Die Idee ist, ich will
über den allgemeinen Begriff davon denken.

305
00:21:38,358 --> 00:21:40,104
Nun, wenn unsere Sprache

306
00:21:40,505 --> 00:21:45,916
eine gute Sprache wird,
um solche allgemeinen Gedanken auszudrücken.

307
00:21:46,902 --> 00:21:50,061
Es geht darum, ob ich das wirklich tun kann.

308
00:21:50,521 --> 00:21:52,659
Also ich möchte sagen können,

309
00:21:54,599 --> 00:22:01,893
Ich werde x mit der Summe
von a1 und a2 multiplizieren,

310
00:22:02,391 --> 00:22:05,647
und ich möchte damit
die allgemeine Idee ausdrücken,

311
00:22:06,032 --> 00:22:08,972
von allen verschiedenen Dingen,
die a1 und a2 sein könnten.

312
00:22:09,916 --> 00:22:13,949
Nun, wenn Sie darüber nachdenken,
gibt es ein Problem, weil immerhin werden die jeweiligen

313
00:22:14,919 --> 00:22:18,120
primitiven Operationen, die in der Maschine vorgehen,
offensichtlich unterschiedlich sein,

314
00:22:18,521 --> 00:22:22,599
wenn ich zwei Zahlen addiere,
als wie wenn ich zwei Polynomiale addiere.

315
00:22:22,900 --> 00:22:27,434
Oder wenn ich die Repräsentation
von zwei elektrischen Signalen oder Wellen addiere.

316
00:22:27,842 --> 00:22:30,077
Irgendwo muss das Wissen

317
00:22:30,434 --> 00:22:35,757
über die verschiedenartigen Dinge sein,
die man addieren kann und wie man sie addiert.

318
00:22:37,045 --> 00:22:38,544
Nun, um so ein System zu konstruieren,

319
00:22:38,845 --> 00:22:40,653
ist die Frage,
wo stelle ich dieses Wissen hin?

320
00:22:41,054 --> 00:22:45,833
Wie denke ich über die verschiedenen
Wahlmäglichkeiten nach, die ich habe? Und wenn morgen

321
00:22:46,252 --> 00:22:50,263
Georg auf eine neue Art Objekt kommt,
das addiert und multipliziert werden könnte,

322
00:22:50,817 --> 00:22:54,483
wie füge ich Georgs neues Objekt zu diesem
System hinzu, ohne alles durcheinanderzubringen,

323
00:22:54,783 --> 00:22:56,596
was schon da war?

324
00:22:57,635 --> 00:23:00,245
Das wird das zweite grosse Thema werden,

325
00:23:00,573 --> 00:23:04,687
die Art und Weise diese Art von
Komlexität zu kontrollieren. Und wie man das macht, ist

326
00:23:05,062 --> 00:23:06,489
indem man

327
00:23:06,921 --> 00:23:09,155
konventionelle Schnittstellen einrichtet.

328
00:23:16,874 --> 00:23:18,642
Agreed-upon ways

329
00:23:19,041 --> 00:23:22,035
Sachen zusammenzustecken,
genau wie die Leute in der Elektrotechnik

330
00:23:22,534 --> 00:23:25,394
Standardimpedanzen
für Anschlüsse haben.

331
00:23:25,909 --> 00:23:28,193
Und dann weiss man, wenn man etwas baut
mit einer der Standardimpedanzen,

332
00:23:28,594 --> 00:23:32,154
kann man es mit etwas anderem zusammenstecken.

333
00:23:32,778 --> 00:23:35,403
Das wird unser zweites
grosses Thema werden, konventionelle Schnittstellen.

334
00:23:35,765 --> 00:23:36,860
Was wir sehen werden,

335
00:23:37,624 --> 00:23:40,504
ist, als erstes werden wir über
das Problem der auswählbaren Operationen sprechen,

336
00:23:40,805 --> 00:23:42,211
das ist das, worauf ich angespielt habe.

337
00:23:42,527 --> 00:23:47,654
Dinge wie Plus, die
mit allen unterschiedlichen Arten von Daten funktionieren müssen.

338
00:23:52,264 --> 00:23:54,361
Also werden wir über auswählbare (generische) Operationen sprechen.

339
00:23:54,662 --> 00:23:57,447
Dann werden wir
über Strukturen mit wirklich grossem Ausmaß sprechen.

340
00:23:57,985 --> 00:24:01,240
Wie baut man
sehr große Programm auf, die

341
00:24:01,641 --> 00:24:04,655
die Arten von komplexen Systemen in der
echten Welt modellieren, die man modellieren möchte.

342
00:24:05,056 --> 00:24:10,046
Und was wir verstehen werden, ist dass
es zwei sehr wichtige Metaphern gibt,

343
00:24:10,447 --> 00:24:11,497
um solche System aufzubauen.

344
00:24:11,798 --> 00:24:16,200
Eine heisst objektorientiertes
Programmieren, wo man sich

345
00:24:16,814 --> 00:24:18,730
sein System ungefähr vorstellt als eine Art Gesellschaft

346
00:24:19,031 --> 00:24:22,507
aus kleinen Dinge, die
durch das Senden von Information zwischen ihnen interagieren.

347
00:24:23,201 --> 00:24:27,466
Und dann die Zweite ist
Operationen auf Aggregaten, genannt Streams,

348
00:24:27,766 --> 00:24:29,137
wo man über ein zusammengebautes

349
00:24:29,438 --> 00:24:32,700
System denkt,
ungefähr so wie ein Signalverarbeitungsingenieur

350
00:24:33,000 --> 00:24:35,857
große elektrische Systeme aufbaut.

351
00:24:38,998 --> 00:24:40,721
Das wird unser zweites großes Thema.

352
00:24:43,065 --> 00:24:45,416
Schliesslich, das dritte große Thema, auf das wir kommen werden,

353
00:24:45,817 --> 00:24:51,096
das dritte grundlegende Verfahren, um
Komplexität zu beherrschen, ist neue Sprachen zu bauen.

354
00:24:51,494 --> 00:24:52,671
Denn manchmal,

355
00:24:53,028 --> 00:24:55,110
wenn man fast überwältigt ist
von der Komplexität eines Entwurfs,

356
00:24:55,487 --> 00:24:59,991
kann man diese Komplexität beherrschen,
indem man sich eine neue Entwurfssprache aussucht.

357
00:25:01,164 --> 00:25:02,542
Und der Zweck der neuen Entwurfssprache

358
00:25:02,843 --> 00:25:05,487
wird sein,
verschiedene Aspekte des Systems hervorzuheben.

359
00:25:05,818 --> 00:25:09,439
Sie wird einige Arten von Details unterdrücken,
und andere Arten von Details hervorheben.

360
00:25:12,446 --> 00:25:15,480
Das wird der dritte,
der magischste Teil unseres Kurses sein.

361
00:25:15,881 --> 00:25:19,202
Wir werden anfangen mit
den Methoden zum Erstellen

362
00:25:19,553 --> 00:25:21,230
neuer Computersprachen.

363
00:25:21,631 --> 00:25:27,089
Und als Erstes werden wir
sogar in LISP aufbauen...

364
00:25:28,318 --> 00:25:33,781
Wir werden in LISP
den Prozess, LISP zu interpretieren, ausdrücken.

365
00:25:34,135 --> 00:25:36,426
Und das wird eine
ziemlich selbstzyklische Sache.

366
00:25:36,727 --> 00:25:39,496
Es gibt ein kleines mystisches Symbol
das damit zu tun hat.

367
00:25:39,831 --> 00:25:43,229
Wir werden verstehen, dass der Prozess
LISP zu interpretieren wie

368
00:25:44,040 --> 00:25:47,427
ein gigantisches Rad ist
von zwei Prozessen, apply und eval,

369
00:25:47,839 --> 00:25:50,988
die andauernd
Ausdrücke aufeinander reduzieren.

370
00:25:52,051 --> 00:25:56,209
Nun, wir werden auch andere magische
Dinge antreffen. Hier ist ein anderes magisches Symbol.

371
00:25:56,980 --> 00:25:58,283
Es ist ungefähr...

372
00:25:59,760 --> 00:26:00,984
Es ist ungefähr der Y-Operator,

373
00:26:01,366 --> 00:26:06,185
der in einem Sinn der Ausdruck der
Unendlichkeit in unserer prozeduralen Sprache ist.

374
00:26:06,520 --> 00:26:07,922
Wir werden uns damit beschäftigen.

375
00:26:08,224 --> 00:26:10,118
Wie auch immer, dieser Abschnitt des Kurses

376
00:26:10,448 --> 00:26:14,007
wird genannt metasprachliche Abstraktion.

377
00:26:15,959 --> 00:26:22,968
Durch Sprechen, Abstrahieren durch Sprechen über

378
00:26:23,945 --> 00:26:26,562
how you construct new languages.

379
00:26:29,830 --> 00:26:31,901
As I said we're gonna start out

380
00:26:32,420 --> 00:26:36,321
mit dem Untersuchen des
Interpretationsprozesses. Wir werden uns diese

381
00:26:36,822 --> 00:26:38,680
apply/eval Schleife ansehen.

382
00:26:40,650 --> 00:26:41,840
And build LISP.

383
00:26:42,224 --> 00:26:44,021
Schliesslich, nur um Ihnen zu zeigen,
dass das sehr allgemeint ist,

384
00:26:44,236 --> 00:26:47,907
werden wir genau dasselbe Vorgehen verwenden,
um eine sehr unterschiedliche Art von Sprache zu bauen,

385
00:26:48,208 --> 00:26:50,294
eine sogenannte logische Programmiersprache.

386
00:26:50,509 --> 00:26:53,081
Wo man überhaupt nicht über
Prozeduren spricht,

387
00:26:53,470 --> 00:26:55,369
die Eingaben und Ausgaben haben.
Was man macht, ist

388
00:26:55,703 --> 00:26:58,535
über Relationen zwischen Dingen zu sprechen.
Und dann schliesslich

389
00:26:59,027 --> 00:27:00,526
werden wir behandeln, wie man

390
00:27:01,080 --> 00:27:05,198
diese Dinge sehr konkret
auf den einfachsten Maschinentypen implementiert.

391
00:27:05,499 --> 00:27:08,355
Sogar... Wir werden sogar etwas wie das sehen,

392
00:27:08,989 --> 00:27:11,718
das ist... das ist ein Bild von einem Chip,

393
00:27:12,049 --> 00:27:16,204
der der LISP Interpreter ist,
von dem wir sprechen werden.

394
00:27:16,680 --> 00:27:18,951
Dann auf der Hardware.

395
00:27:19,823 --> 00:27:24,119
OK. Ja, das ist ein Abriss
des Kurses, drei grosse Themen:

396
00:27:24,753 --> 00:27:29,846
Black-Box Abstraktion, konventionelle
Schnittstellen, metasprachliche Abstraktion.

397
00:27:31,067 --> 00:27:35,663
Nun, machen wir jetzt eine Pause
und dann werden wir loslegen.

398
00:28:03,802 --> 00:28:07,004
Also, lassen Sie uns jetzt wirklich
anfangen, LISP zu lernen.

399
00:28:07,853 --> 00:28:10,086
Eigentlich... Fangen wir an
etwas viel Wichtigeres zu lernen.

400
00:28:10,486 --> 00:28:12,613
Vielleicht das Allerwichtigste
in diesem Kurs.

401
00:28:13,074 --> 00:28:14,525
Das ist natürlich nicht LISP im Besonderen,

402
00:28:14,869 --> 00:28:19,885
sondern eher ein allgemeines Gerüst,
um über Sprachen nachzudenken.

403
00:28:20,606 --> 00:28:24,409
Ich habe schon hingewiesen darauf, wenn Ihnen jemand sagt
eine Sprache zu zeigen,

404
00:28:24,809 --> 00:28:27,341
was Sie sagen sollten ist:
in Ordnung, du sollst mir sagen,

405
00:28:27,685 --> 00:28:33,916
was sind die primitiven Elemente?

406
00:28:37,444 --> 00:28:38,622
Was bringt die Sprache mit?

407
00:28:39,009 --> 00:28:43,328
Dann, wie geht es,
diese zusammenzusetzen?

408
00:28:43,629 --> 00:28:47,984
Welche Mittel der Kombination gibt es?

409
00:28:50,215 --> 00:28:53,905
Was sind die Dinge, die dir ermöglichen,
diese primitiven Elemente zu nehmen

410
00:28:54,383 --> 00:28:56,747
und größere Dinge daraus zu bauen?

411
00:28:57,775 --> 00:29:00,402
Welche Wege gibt es,
Dinge zusammenzubauen?

412
00:29:01,175 --> 00:29:07,347
Und dann,
was sind die Mittel der Abstraktion?

413
00:29:08,018 --> 00:29:12,979
Wie nehmen wir diese komplizierten Dinge

414
00:29:15,535 --> 00:29:16,624
und zeichnen Boxen um sie?

415
00:29:16,914 --> 00:29:18,143
Wie benennen wir sie,

416
00:29:18,463 --> 00:29:21,208
so daß wir sie jetzt verwenden können
als ob sie primitive Elemente wären,

417
00:29:21,593 --> 00:29:25,934
um noch kompliziertere Dinge zu machen
und so weiter, und so weiter, und so weiter?

418
00:29:26,834 --> 00:29:29,609
Also, wenn Ihnen jemand sagt:
Mensch, ich habe eine großartige neue Computersprache!

419
00:29:30,563 --> 00:29:34,606
Sagen Sie nicht: Wie viele Zeichen
braucht es, um eine Matrix zu invertieren?

420
00:29:35,575 --> 00:29:36,934
Oder? Es ist irrelevant.

421
00:29:37,284 --> 00:29:38,282
Oder? Was Sie sagen ist:

422
00:29:38,607 --> 00:29:41,965
Falls die Sprache
nicht mit eingebauten Matrizen

423
00:29:42,307 --> 00:29:45,510
oder etwas anderem eingebaut gekommen wäre,
wie könnte ich dann dieses Ding bauen?

424
00:29:45,887 --> 00:29:48,246
Welche Kombinationsmittel gibt es,
die mir das ermöglichen würden?

425
00:29:48,547 --> 00:29:50,656
Und dann,
welche Abstraktionsmittel gibt es,

426
00:29:51,491 --> 00:29:53,708
die mir ermöglichen,
dann diese Elemente zu verwenden,

427
00:29:54,009 --> 00:29:56,782
um noch kompliziertere Dinge zu erzeugen?

428
00:29:58,904 --> 00:30:01,485
Also, wir werden feststellen,
dass LISP einige primitive Daten

429
00:30:02,103 --> 00:30:04,593
und einige primitive Prozeduren hat.

430
00:30:05,375 --> 00:30:08,370
Genau genommen, lassen Sie uns wirklich anfangen.

431
00:30:08,771 --> 00:30:13,069
Und hier ist ein Stück
primitive Daten in LISP. Mal schauen...

432
00:30:13,741 --> 00:30:16,138
Die Zahl 3.

433
00:30:16,682 --> 00:30:19,417
Eigentlich, um sehr pedantisch zu sein,
das ist nicht die Zahl 3.

434
00:30:19,857 --> 00:30:25,516
Das ist irgendein Symbol, das repräsentiert...
das spielt die Rolle der Zahl 3.

435
00:30:26,560 --> 00:30:33,014
Und hier ist noch ein...
hier sind mehr eher primitive Daten in LISP.

436
00:30:34,767 --> 00:30:39,733
Siebzehn punkt 4.
Eigentlich eine Repräsentation von 17.4.

437
00:30:40,844 --> 00:30:45,649
Und hier eine andere. Fünf.

438
00:30:46,490 --> 00:30:49,624
Hier ist ein anderes
primitives Objekt, das in LISP integriert ist.

439
00:30:51,610 --> 00:30:56,477
Addition. Eigentlich, wenn wir dieselbe
Genauigkeit anlegen, ist das ein Name

440
00:30:56,870 --> 00:30:59,528
für die primitive Methode,
die Dinge addiert.

441
00:31:00,129 --> 00:31:02,207
So wie das eine Bezeichnung
ist für das, was die Zahl 3 spielte,

442
00:31:02,508 --> 00:31:09,145
ist das eine Bezeichnung dafür, was 
die Rolle gespielt hat, wie man Sachen addiert.

443
00:31:10,137 --> 00:31:11,714
Also dies sind einige primitiven Elemente.

444
00:31:12,066 --> 00:31:13,813
Ich kann sie zusammensetzen.

445
00:31:14,114 --> 00:31:18,304
Ich kann sagen, na,
was ist die Summe von 3 und 17.4 und 5?

446
00:31:18,608 --> 00:31:24,071
Wie ich das mache ist, ich wende

447
00:31:24,975 --> 00:31:31,494
den Summenoperator auf diese drei Zahlen an.
Und was sollte ich rauskriegen? 8, 17,... 25.4.

448
00:31:34,107 --> 00:31:38,152
Also, ich sollte LISP fragen können,
was der Wert davon ist.

449
00:31:38,692 --> 00:31:41,501
Und es wird 25.4 zurückgeben.

450
00:31:43,117 --> 00:31:47,199
Lassen Sie uns einige Bezeichnungen einführen.
Das Ding das ich eingetippt habe

451
00:31:49,745 --> 00:31:55,242
heisst Kombination.

452
00:31:56,555 --> 00:32:02,744
Und eine Kombination besteht allgemein
aus dem Anwenden eines Operators

453
00:32:03,313 --> 00:32:05,420
(also das ist ein Operator)

454
00:32:09,660 --> 00:32:15,408
auf einige Operanden
(dies sind die Operanden)

455
00:32:21,429 --> 00:32:23,309
Und natürlich
kann ich komplexere Dinge machen.

456
00:32:23,610 --> 00:32:28,623
Warum ich Komplexität daraus bekommen kann,
ist weil die Operanden selbst generell

457
00:32:29,267 --> 00:32:30,972
Kombinationen sein können.

458
00:32:31,273 --> 00:32:33,133
Also zum Beispiel, Ich könnte sagen, was ist

459
00:32:33,534 --> 00:32:41,190
die Summe von 3 und dem Produkt von 5, und 6,

460
00:32:41,749 --> 00:32:44,264
und 8, und 2.

461
00:32:45,100 --> 00:32:47,158
Und ich sollte bekommen, schaun wir mal...

462
00:32:47,514 --> 00:32:54,849
30, 40,... 43.
Also LISP sollte mir antworten, dass das 43 ist.

463
00:32:55,785 --> 00:32:58,387
Kombinationen zu bilden...

464
00:32:58,920 --> 00:33:02,724
nun, ist das grundlegende Kombinationsmittel,
das wir haben werden.

465
00:33:04,341 --> 00:33:09,302
Nun, und dann, Sie sehen hier ein bisschen Syntax.

466
00:33:10,289 --> 00:33:14,801
LISP verwendet die sogenannte Präfixnotation,

467
00:33:16,259 --> 00:33:20,197
das heisst, dass der Operator

468
00:33:21,347 --> 00:33:26,411
links von den Operanden geschrieben wird.
Es ist nur eine Konvention.

469
00:33:27,495 --> 00:33:29,610
Und beachten Sie, dass es vollständig geklammert ist.

470
00:33:29,943 --> 00:33:32,013
Und die Klammern
machen es völlig eindeutig.

471
00:33:32,292 --> 00:33:34,460
Also wenn ich das ansehe, sehe ich, dass

472
00:33:35,824 --> 00:33:41,162
es einen Operator gibt und
einen,... zwei,... drei,... vier Operanden.

473
00:33:42,817 --> 00:33:47,906
Und ich kann feststellen, dass der zweite Operand
hier selbst irgendeine Kombination ist,

474
00:33:48,876 --> 00:33:51,621
die einen Operator und zwei Operanden hat.

475
00:33:52,445 --> 00:33:54,211
Klammern in LISP sind ein bisschen...

476
00:33:54,585 --> 00:33:57,354
naja, sie sind sehr unähnlich zu
Klammern aus konventioneller Mathematik.

477
00:33:57,611 --> 00:34:00,122
In der Mathematik verwenden wir sie sozusagen
um Gruppierung anzuzeigen.

478
00:34:01,157 --> 00:34:03,475
Und es macht irgendwie nichts aus, wenn man manchmal
Klammern weglässt, sofern

479
00:34:03,792 --> 00:34:05,447
die Leute verstehen, dass das gruppiert ist.

480
00:34:05,769 --> 00:34:08,313
Und im Allgemeinen macht es nichts aus,
mehr Klammern zu setzen,

481
00:34:08,628 --> 00:34:11,706
weil es vielleicht die Gruppierung
hervorhebt. So ist LISP nicht!

482
00:34:12,880 --> 00:34:18,952
In LISP kann man keine Klammern weglassen.
Und man kann keine extra Klammern setzen.

483
00:34:19,153 --> 00:34:22,673
Weil Klammern zu setzen
bedeutet immer genau und deutlich,

484
00:34:23,225 --> 00:34:25,809
dass das eine Kombination ist,

485
00:34:26,168 --> 00:34:28,820
was bedeutet,
Operator auf Operanden anzuwenden.

486
00:34:29,140 --> 00:34:30,673
Und wenn ich die weglassen würde,...

487
00:34:31,263 --> 00:34:34,239
wenn ich diese Klammern weglassen würde,
würde es etwas anderes aussagen.

488
00:34:35,249 --> 00:34:36,950
In fact, the way to think about this is:

489
00:34:37,251 --> 00:34:40,097
Really what I'm doing,
when I write something like this,

490
00:34:40,439 --> 00:34:41,974
ist einen Baum zu schreiben.

491
00:34:42,371 --> 00:34:44,372
Also diese Kombination ist ein Baum,

492
00:34:44,729 --> 00:34:48,294
der hat ein Plus, und dann eine 3,

493
00:34:48,939 --> 00:34:54,010
und dann etwas anderes,
und dann 8, und eine 2.

494
00:34:54,345 --> 00:34:58,455
Und dann das andere hier
ist selbst ein kleiner Unterbaum,

495
00:34:59,526 --> 00:35:03,154
der hat ein Mal, und eine 5, und eine 6.

496
00:35:03,685 --> 00:35:06,487
And the way to think of that is:
really, what's going on

497
00:35:07,237 --> 00:35:12,917
ist, diese Bäume umzuschreiben,
und Klammern sind nur eine Möglichkeit,

498
00:35:13,268 --> 00:35:17,625
um diese zweidimensionale Struktur
als eine lineare Zeichenkette zu schreiben.

499
00:35:18,868 --> 00:35:21,189
Denn als es LISP zuerst gab,

500
00:35:21,590 --> 00:35:23,632
hatten die Leute Fernschreiber
oder Lochkarten oder was auch immer...

501
00:35:23,953 --> 00:35:25,248
Das war praktischer.

502
00:35:25,845 --> 00:35:30,458
Wenn LISP heute anfangen würde,
würde die Syntax von LISP vielleicht so aussehen.

503
00:35:31,891 --> 00:35:35,547
Nun, sehen wir uns an wie
das eigentlich am Computer aussieht.

504
00:35:36,382 --> 00:35:40,569
Hier habe ich eine LISP
Eingabeaufforderung. Da ist ein Editor.

505
00:35:40,970 --> 00:35:44,721
Und darauf werde ich paar Werte eintippen
und LISP fragen, was die sind.

506
00:35:45,074 --> 00:35:48,732
Also zu Beispiel, Ich kann LISP sagen,
was ist der Wert dieses Symbols?

507
00:35:49,313 --> 00:35:53,278
Das ist 3. Und ich bitte LISP es auszuwerten.
Und hier sehen Sie, LISP ist

508
00:35:53,899 --> 00:35:57,375
unten erschienen
und hat gesagt, oh, ja, das ist 3.

509
00:35:57,631 --> 00:36:08,139
Oder ich kann sagen was ist die Summe von 3 und 4
und 8? Was ist diese Kombination?

510
00:36:08,968 --> 00:36:11,852
Und ich bitte LISP es auszuwerten.

511
00:36:13,776 --> 00:36:15,853
Das ist 15.

512
00:36:16,401 --> 00:36:20,736
Oder ich kann etwas
Komplizierteres eintippen. Ich kann sagen, was ist die Summe...

513
00:36:21,175 --> 00:36:24,931
vom Produkt aus 3...

514
00:36:25,369 --> 00:36:33,847
und der Summe von 7 und 19.5...

515
00:36:34,993 --> 00:36:36,150
Und Sie merken hier,

516
00:36:36,548 --> 00:36:38,530
dass LISP etwas integriert hat
das mir hilft, die Übersicht

517
00:36:38,876 --> 00:36:41,724
über all diese Klammern zu behalten. Passen Sie auf
wenn ich die nächste schliessende Klammer tippe,

518
00:36:42,100 --> 00:36:45,365
die die
Kombination schliessen wird, die mit dem Mal beginnt.

519
00:36:45,728 --> 00:36:47,277
Die Öffnende wird aufblinken.

520
00:36:47,696 --> 00:36:49,875
Dort. Ich werde die wegradieren und es wiederholen...

521
00:36:50,133 --> 00:36:52,787
Tippe schließen,
und Sie sehen das schließt das Plus.

522
00:36:53,428 --> 00:36:56,793
Nochmal schließen schließt das Mal.

523
00:36:57,657 --> 00:37:00,916
Jetzt bin ich wieder bei der Summe
und vielleicht werden zu all dem 4 addieren

524
00:37:01,480 --> 00:37:04,226
Das schließt das Plus,
jetzt habe ich eine abgeschlossene Kombination.

525
00:37:04,678 --> 00:37:08,545
Und ich kann LISP nach dem Wert
davon fragen. Diese Art Klammerausgleich

526
00:37:09,185 --> 00:37:12,763
ist in vielen
LISP Systemen eingebaut, um den Überblick halten zu helfen.

527
00:37:13,148 --> 00:37:16,504
weil es irgendwie langweilig ist,
all die Klammern von Hand zu machen.

528
00:37:16,886 --> 00:37:20,732
Da gibt es eine andere Konvention,
um die Klammern zu verfolgen.

529
00:37:21,033 --> 00:37:23,898
Lassen Sie mich eine andere
komplizierte Kombination schreiben.

530
00:37:24,704 --> 00:37:27,153
Sagen wir die Summe vom

531
00:37:27,695 --> 00:37:31,642
Produkt von 3 und 5,

532
00:37:32,819 --> 00:37:36,830
und addiere das auf etwas und jetzt
was ich mache, ich werde einrücken,

533
00:37:37,117 --> 00:37:39,630
that the operands are written vertically.

534
00:37:40,010 --> 00:37:41,869
It's the sum of that and the product

535
00:37:42,287 --> 00:37:49,335
aus 47 und... sagen wir das Produkt aus 47

536
00:37:50,047 --> 00:37:57,345
und der Differenz aus 20 und 6.8
(das heißt ziehe 6.8 von 20 ab)

537
00:37:58,462 --> 00:38:03,163
Jetzt sehen Sie Klammern schliessen
schließe das Minus, schließe das Mal...

538
00:38:03,793 --> 00:38:04,949
Und jetzt einen anderen Operator...

539
00:38:05,292 --> 00:38:07,332
Sie sehen,
der LISP Editor rückt hier

540
00:38:07,707 --> 00:38:12,290
automatisch auf die richtige Position ein,
für meine Übersicht.

541
00:38:12,726 --> 00:38:18,326
Ich werde die letzte Klammer nochmal schließen,
Sie sehen nochmal, es gleicht das Plus aus

542
00:38:19,803 --> 00:38:22,970
Richtig, jetzt kann ich sagen
was ist der Wert davon?

543
00:38:23,614 --> 00:38:27,448
Richtig, also diese zwei Dinge:

544
00:38:27,844 --> 00:38:30,604
das Einrücken auf die richtige Stufe,
genannt pretty printing (hübsches Drucken),

545
00:38:31,357 --> 00:38:33,587
und blinkende Klammern

546
00:38:33,899 --> 00:38:36,579
sind die zwei Dinge, die in vielen
LISP Systeme eingebaut sind

547
00:38:36,869 --> 00:38:39,491
um zu helfen, den Überblick zu wahren
und Sie sollten lernen, sie zu benutzen.

548
00:38:41,524 --> 00:38:43,238
OK. Also, das sind die Primitive.

549
00:38:44,669 --> 00:38:48,151
Es gibt ein Mittel der Kombination.
Gehen wir jetzt zur Abstraktionsmöglichkeit.

550
00:38:49,258 --> 00:38:53,404
Es soll mir möglich sein diese Idee, dass
ich irgend so eine Kombination mache,

551
00:38:53,750 --> 00:38:56,842
und sie abstrahiere und ihr einen einfachen
Namen gebe, so dass ich sie als Element verwenden kann,

552
00:38:57,243 --> 00:39:00,510
und das mache ich in LISP mit define.

553
00:39:00,910 --> 00:39:07,969
Also ich könnte zum Beispiel sagen definiere A

554
00:39:08,802 --> 00:39:15,713
als das Produkt von 5 und 5.

555
00:39:17,720 --> 00:39:21,334
Und jetzt könnte ich zum Beispiel LISP sagen

556
00:39:21,964 --> 00:39:26,655
was ist das Produkt von A und A?

557
00:39:27,258 --> 00:39:30,494
Und das sollte 25 sein,
und das sollte 625 sein.

558
00:39:31,544 --> 00:39:35,734
Und jetzt, das Entscheidende ist, ich kann A jetzt verwenden.

559
00:39:36,135 --> 00:39:37,836
Hier habe ich es in der Kombination verwendet,

560
00:39:38,249 --> 00:39:43,157
aber ich könnte das in anderen
komplizierteren Dingen verwenden, die ich wiederum benenne.

561
00:39:43,508 --> 00:39:48,379
Also ich könnte B definieren

562
00:39:49,554 --> 00:39:57,192
als Summe von A und dem Produkt aus 5 und A.

563
00:39:59,409 --> 00:40:01,017
... und das Plus schließen...

564
00:40:02,939 --> 00:40:06,202
Sehen wir uns das im
Computer an, wie das dort aussieht.

565
00:40:07,992 --> 00:40:10,333
Also, nun, ich werde einfach eintippen,
was auf der Tafel steht.

566
00:40:10,704 --> 00:40:16,878
Ich könnte sagen wir A definieren

567
00:40:17,609 --> 00:40:21,817
als das Produkt von 5 und 5.

568
00:40:24,023 --> 00:40:25,334
Ich sage das LISP

569
00:40:25,713 --> 00:40:28,707
und beachten Sie, dass LISP
hier unten mit einem A geantwortet hat.

570
00:40:29,148 --> 00:40:31,082
Allgemein
wenn man eine Definition in LISP eintippt,

571
00:40:31,524 --> 00:40:34,887
antwortet es mit dem definierten Symbol.

572
00:40:35,561 --> 00:40:41,600
Jetzt könnte ich LISP sagen,
was ist das Produkt von A und A?

573
00:40:42,538 --> 00:40:44,549
So sagt es 625.

574
00:40:45,728 --> 00:40:50,321
Ich kann B definieren

575
00:40:51,324 --> 00:40:57,585
als Summe von A und dem Produkt

576
00:40:57,986 --> 00:41:04,344
aus 5 und A, Klammern schließen,
Mal schließen, Plus schließen.

577
00:41:04,752 --> 00:41:06,835
Das define schließen.

578
00:41:07,621 --> 00:41:09,060
LISP sagt:
OK. B.

579
00:41:09,337 --> 00:41:13,850
Hier unten. Und jetzt
kann ich LISP sagen, was ist der Wert von B?

580
00:41:17,010 --> 00:41:20,018
Und ich kann etwas
komplizierteres sagen wie, was ist die Summe

581
00:41:20,367 --> 00:41:26,205
von A und dem Quotienten aus B und 5?

582
00:41:26,582 --> 00:41:30,032
Der Schrägstrich ist Teilen,
ein anderer primitiver Operator.

583
00:41:30,379 --> 00:41:33,001
Ich habe B durch 5 geteilt und das auf 5 addiert.

584
00:41:33,502 --> 00:41:35,774
LISP sagt:
OK. Das ist 55.

585
00:41:36,509 --> 00:41:38,152
Alles klar. Also so würde das aussehen.

586
00:41:39,786 --> 00:41:42,913
Das sind die Grundmittel
um etwas zu definieren.

587
00:41:43,355 --> 00:41:49,341
Es ist die einfachste Art, etwas zu benennen,
aber es ist nicht wirklich sehr mächtig.

588
00:41:49,812 --> 00:41:53,157
Sehen Sie, was ich wirklich benennen möchte...
Ich werde über allgemeine Methoden sprechen...

589
00:41:53,498 --> 00:41:55,848
Ich möchte die ganz allgemeine Idee benennen,

590
00:41:56,313 --> 00:42:00,626
dass ich zum Beispiel 5 mit 5 multiplizieren könnte

591
00:42:03,213 --> 00:42:06,141
... oder 6 mit 6,...

592
00:42:06,419 --> 00:42:12,719
... oder 1001 mit 1001,

593
00:42:14,653 --> 00:42:17,531
... oder 1001.7 mit 1001.7

594
00:42:17,830 --> 00:42:20,624
Alright, I'd like to be able
die allgemeine Idee benennen können,

595
00:42:22,127 --> 00:42:24,408
etwas mit sich selbst zu multiplizieren.

596
00:42:28,289 --> 00:42:30,105
Wir wissen, das
nennt man Quadrieren.

597
00:42:31,558 --> 00:42:33,844
Und wie ich das in LISP machen kann ist,

598
00:42:34,463 --> 00:42:36,827
zu sagen

599
00:42:37,576 --> 00:42:40,790
define...

600
00:42:43,371 --> 00:42:49,465
um ein Ding X zu quadrieren (square),

601
00:42:51,907 --> 00:42:56,974
multipliziere X mit sich selbst.

602
00:42:57,849 --> 00:43:00,173
Und wenn ich das gemacht habe, kann ich

603
00:43:00,643 --> 00:43:08,068
LISP zum Beispiel sagen, was
ist das Quadrat von 10? Und LISP wird 100 sagen.

604
00:43:11,914 --> 00:43:14,472
Sehen wir uns das noch
etwas genauer an.

605
00:43:15,337 --> 00:43:19,702
Da ist die Definition von Quadrieren (square)
Um etwas zu quadrieren,

606
00:43:20,258 --> 00:43:23,260
multipliziere es mit sich selbst.

607
00:43:23,661 --> 00:43:25,688
Sie sehen das X hier.

608
00:43:26,284 --> 00:43:29,622
Oder? Dieses X ist eine Art Pronomen, das
ist das, was ich quadrieren werde.

609
00:43:31,275 --> 00:43:37,572
Und ich multipliziere X jetzt mit sich selbst.

610
00:43:44,026 --> 00:43:47,703
OK. Also es gibt eine Notation
um eine Prozedur zu definieren.

611
00:43:48,104 --> 00:43:50,336
Das ist tatsächlich ein bisschen verwirrend,

612
00:43:50,755 --> 00:43:55,214
weil es ist ein bisschen so, wie ich
square verwenden könnte und sagen square von X,

613
00:43:55,600 --> 00:43:56,992
oder square von 10,

614
00:43:57,463 --> 00:44:01,836
aber es ist nicht sehr klar gemacht,
dass ich eigentlich etwas benenne.

615
00:44:02,985 --> 00:44:05,213
So, lassen Sie mich diese
Definition anders schreiben,

616
00:44:05,609 --> 00:44:08,026
das es ein bisschen klarer macht,
dass ich etwas benenne.

617
00:44:08,427 --> 00:44:14,386
Ich werde sagen definiere square

618
00:44:17,984 --> 00:44:20,709
als

619
00:44:22,281 --> 00:44:29,820
lambda von X, mal X X.

620
00:44:36,202 --> 00:44:38,563
Hier benenne ich etwas square.

621
00:44:39,177 --> 00:44:42,513
Genau wie ich hier drüben
etwas A benenne.

622
00:44:43,057 --> 00:44:44,435
Das Ding das ich square benannt habe...

623
00:44:44,831 --> 00:44:48,642
Here benannte ich... das Ding das ich A benannte
war der Wert dieser Kombination.

624
00:44:49,179 --> 00:44:52,928
Hier, das Ding das ich square benenne,
ist das Ding das mit lambda anfängt

625
00:44:53,354 --> 00:44:57,471
und lambda ist LISPs Art
zu sagen "mach eine Prozedur".

626
00:45:00,097 --> 00:45:03,080
Schauen wir uns das
etwas genauer auf einer Folie an.

627
00:45:03,925 --> 00:45:11,267
Wie ich diese Definition lese ist,
I define square to be: make a procedure

628
00:45:12,602 --> 00:45:13,772
(dafür ist das lambda)

629
00:45:14,151 --> 00:45:17,234
Mache eine Prozedur
mit einem Argument genannt X

630
00:45:18,919 --> 00:45:23,838
und was sie macht ist,
das Ergebnis der Multiplikation von X mit sich selbst zurückzugeben.

631
00:45:24,871 --> 00:45:29,562
Nun, im Allgemeinen werden wir verwenden...

632
00:45:30,572 --> 00:45:32,846
Wir werden
diese obere Form der Definition verwenden.

633
00:45:33,386 --> 00:45:34,884
Weil
es ein bisschen bequemer ist.

634
00:45:35,185 --> 00:45:38,526
Aber vergessen Sie nicht,
dass es in Wirklichkeit das ist.

635
00:45:38,835 --> 00:45:41,233
In der Tat, soweit
der LISP Interpreter betroffen ist,

636
00:45:41,578 --> 00:45:45,829
gibt es keinen Unterschied dazwischen,
das einzutippen und das einzutippen.

637
00:45:46,443 --> 00:45:48,995
Und es gibt eine Bezeichnung dafür:

638
00:45:50,650 --> 00:45:53,724
"Syntactic sugar"
1
639
00:45:54,416 --> 00:45:56,888
Syntaktischer Zucker heisst, es gibt

640
00:45:57,784 --> 00:46:01,058
etwas bequemere
Abkürzungen, um etwas einzutippen.

641
00:46:01,921 --> 00:46:06,416
Also das ist wirklich nur syntaktischer Zucker
für das zugrundeliegende lambda-Ding.

642
00:46:07,257 --> 00:46:09,752
Und warum Sie sich
das merken sollten ist, vergessen Sie nicht,

643
00:46:10,128 --> 00:46:13,875
dass wenn ich sowas schreibe,
benenne ich eigentlich etwas.

644
00:46:14,236 --> 00:46:15,896
Ich benenne etwas square

645
00:46:16,202 --> 00:46:18,394
und das etwas,
das ich benenne, ist eine Prozedur

646
00:46:18,778 --> 00:46:20,560
die aufgebaut wird.

647
00:46:21,317 --> 00:46:23,823
OK. Nun, schauen wir uns
das auch am Computer an.

648
00:46:24,739 --> 00:46:27,970
Also ich komme rein und ich sage define

649
00:46:29,383 --> 00:46:36,461
square von X als mal X X.

650
00:46:39,475 --> 00:46:42,174
Und ich kann...

651
00:46:49,310 --> 00:46:52,461
OK. Ich sage das LISP.

652
00:46:53,325 --> 00:46:57,952
Es antwortet square, weil ich
etwas square benannt habe, und danach

653
00:46:58,473 --> 00:47:04,230
kann ich LISP fragen,
for what's the square of 1001?

654
00:47:05,016 --> 00:47:09,559
Oder allgemein könnte ich sagen,

655
00:47:10,136 --> 00:47:18,448
was ist das Quadrat von der Summe von 5 und 7?

656
00:47:22,700 --> 00:47:24,670
Oder? 12 quadriert ist 144.

657
00:47:25,124 --> 00:47:28,240
Oder ich kann square selbst
als Element in einer Kombination verwenden.

658
00:47:28,641 --> 00:47:39,179
Ich kann sagen, was ist die Summe vom
Quadrat von 3 und dem Quadrat von 4?

659
00:47:41,293 --> 00:47:44,610
Oder? 9 und 16 ist 25.

660
00:47:45,129 --> 00:47:49,843
Oder ich kann square als Element
in irgendeinem viel komplizierteren Ding verwenden.

661
00:47:50,344 --> 00:48:01,533
Ich kann sagen, was ist das Quadrat vom
Quadrat vom Quadrat von 1001?

662
00:48:07,624 --> 00:48:10,746
Und hier ist das Quadrat
vom Quadrat vom Quadrat von 1001.

663
00:48:11,238 --> 00:48:16,941
Nun, ich kann LISP sagen was ist square
selbst? Was ist der Wert davon?

664
00:48:17,358 --> 00:48:19,633
Und LISP gibt mir auf eine konventionelle Art zurück,

665
00:48:20,077 --> 00:48:21,838
dass das eine Prozedur ist

666
00:48:22,339 --> 00:48:23,934
es sagt: zusammengesetzte Prozedur square (compound procedure square).

667
00:48:24,257 --> 00:48:26,367
Und der Wert von square ist

668
00:48:26,895 --> 00:48:30,718
diese Prouzedur. Und die Sachen 
mit den Mals und den Klammern

669
00:48:31,101 --> 00:48:34,964
ist nur LISPs konventionelle Art,
das zu erklären.

670
00:48:36,287 --> 00:48:38,417
OK. Sehen wir uns...

671
00:48:39,295 --> 00:48:41,305
at two more examples of define.

672
00:48:44,714 --> 00:48:46,767
Hier sind zwei weitere Prozeduren.

673
00:48:47,216 --> 00:48:52,927
Ich kann das Mittel (average) von X und Y definieren
als Summe von X und Y geteilt durch 2.

674
00:48:54,520 --> 00:49:01,098
Oder nachdem wir average und square hatten,

675
00:49:01,601 --> 00:49:04,453
kann ich das benutzen um über
den Quadratsdurchschnitt (mean-square) von etwas zu sprechen.

676
00:49:04,837 --> 00:49:09,995
Das ist das Mittel
vom Quadrat von X und dem Quadrat von Y ist.

677
00:49:10,719 --> 00:49:12,639
Also zu Beispiel, könnte ich danach

678
00:49:13,089 --> 00:49:15,865
sagen, was ist der Quadratsdurchschnitt

679
00:49:22,192 --> 00:49:30,658
von 2 und 3? Und ich sollte
das Mittel von 4 und 9, also 6.5 bekommen.

680
00:49:32,815 --> 00:49:34,209
Der Schlüssel hier

681
00:49:34,965 --> 00:49:38,730
ist, square definiert zu haben.
Ich kann es benutzen wie wenn es primitiv wäre.

682
00:49:41,413 --> 00:49:44,072
Wenn wir hier auf die Folie sehen...

683
00:49:44,473 --> 00:49:45,831
Wenn ich mean-square ansehe...

684
00:49:47,233 --> 00:49:49,708
Die Person, die mean-square definiert

685
00:49:50,155 --> 00:49:52,433
doesn't have to know, at this point,

686
00:49:52,768 --> 00:49:55,788
ob square
in der Sprache integriert

687
00:49:56,896 --> 00:49:59,211
oder ob es eine definierte Prozedur
war.

688
00:49:59,649 --> 00:50:01,910
Und das ist ein Schlüsselelement in LISP.

689
00:50:02,280 --> 00:50:06,460
Dass man keinen
willkürlichen Unterschied machen muss

690
00:50:06,866 --> 00:50:09,350
zwischen Dingen, die zufällig
primitv sind in der Sprache,

691
00:50:09,779 --> 00:50:12,382
und Dingen die zufällig eingebaut sind.

692
00:50:12,808 --> 00:50:16,218
Die benutzende Person sollte es nicht einmal
wissen müssen. Also die Dinge, die man konstruiert

693
00:50:16,520 --> 00:50:19,342
werden mit der ganzen Mächtigkeit und
Flexibilität verwendet, als ob es Primitive wären.

694
00:50:19,743 --> 00:50:23,010
Wir können das
am Computer nochmal setzen lassen.

695
00:50:24,608 --> 00:50:28,952
Wir haben über Plus gesprochen. Und zwar,
wenn ich hier vor den Computerbildschirm komme,

696
00:50:29,528 --> 00:50:32,756
and say what is the value of + ?

697
00:50:34,176 --> 00:50:35,836
Beachten Sie was LISP ausgibt.

698
00:50:36,192 --> 00:50:38,987
Hier unten
wird ausgegeben compund procedure +.

699
00:50:39,887 --> 00:50:42,420
Weil es stellt sich heraus, dass in diesem System

700
00:50:42,821 --> 00:50:45,562
der Additionsoperator
selbst eine zusammengesetzte Prozedur ist.

701
00:50:45,885 --> 00:50:47,735
Und wenn ich das nicht eingeben würde,
hätten Sie das nie gewusst

702
00:50:48,092 --> 00:50:49,929
und es hätte eh keinen
Unterschied gemacht. Es ist uns egal.

703
00:50:50,230 --> 00:50:53,394
Es ist unter dem
Abstraktionslevel, mit dem wir uns beschäftigen.

704
00:50:54,096 --> 00:50:57,826
Also, der Schlüssel ist, dass man nicht sagen kann...
allgemein nicht 

705
00:50:58,647 --> 00:51:02,190
den Unterschied
zwischen eingebauten Dingen

706
00:51:02,572 --> 00:51:03,572
und zusammengesetzten Dingen sagen können sollte.

707
00:51:03,868 --> 00:51:05,441
Warum das?
Weil Dinge, die zusammengesetzt sind

708
00:51:05,758 --> 00:51:08,232
eine Abstraktionshülle
um sie gewickelt haben.

709
00:51:09,112 --> 00:51:11,901
OK. Wir haben jetzt fast
alle Elemente von LISP kennengelernt.

710
00:51:12,658 --> 00:51:14,121
Es gibt nur noch eins, das wir anschauen müssen.

711
00:51:14,469 --> 00:51:16,216
Und das ist, wie man eine Fallzerlegung macht.

712
00:51:16,583 --> 00:51:18,064
Lassen Sie mich zeigen, was ich meine.

713
00:51:18,792 --> 00:51:20,399
Wir könnten über die

714
00:51:21,098 --> 00:51:23,825
mathematische Definition
der Betragsfunktion nachdenken.

715
00:51:24,203 --> 00:51:27,807
Ich könnte sagen, der Betrag von X

716
00:51:28,624 --> 00:51:31,227
ist die Funktion, die die Eigenschaft hat,

717
00:51:31,682 --> 00:51:34,366
dass sie das negative von X,

718
00:51:35,639 --> 00:51:37,409
für X kleiner als Null,

719
00:51:37,915 --> 00:51:41,423
Null für X gleich Null ist,

720
00:51:42,398 --> 00:51:47,114
und X für X größer als Null ist.

721
00:51:49,125 --> 00:51:51,199
Und LISP kennt eine Möglichkeit, diese Fallzerlegung zu machen.

722
00:51:51,546 --> 00:51:53,816
Lassen Sie mich Ihnen den Betrag definieren.

723
00:51:55,499 --> 00:52:00,737
Schreibe define der absolute Wert (abs) von X ist

724
00:52:01,485 --> 00:52:06,438
bedingt (conditional)... Das heisst
Fallzerlegung - cond.

725
00:52:09,272 --> 00:52:14,608
Wenn X kleiner als Null ist,

726
00:52:15,288 --> 00:52:19,736
ist die Antwort negiere X.

727
00:52:22,699 --> 00:52:26,640
Genau, was ich hier geschrieben habe
ist ein Fall. Das ist ein...

728
00:52:28,687 --> 00:52:32,199
Dieses etwas ist ein Konditionalfall.

729
00:52:34,130 --> 00:52:41,602
Und er hat zwei Teile.
This part here is a predicate,...

730
00:52:44,112 --> 00:52:45,719
oder Bedingung, das ist eine Bedingung.

731
00:52:46,020 --> 00:52:48,060
Die Bedingung ist ausgedrückt
durch ein sogenanntes Prädikat.

732
00:52:48,456 --> 00:52:50,928
Und in LISP ist ein Prädikat
eine Art Ding,

733
00:52:51,331 --> 00:52:53,050
das entweder wahr oder falsch zurückgibt.

734
00:52:53,478 --> 00:52:56,594
Und Sie sehen, dass LISP
a primitive procedure 'less than',

735
00:52:57,225 --> 00:52:59,587
die prüft,
ob etwas wahr ist oder falsch.

736
00:53:00,518 --> 00:53:02,555
Und der andere Teil eines Falls

737
00:53:03,491 --> 00:53:06,676
ist eine Aktion oder, etwas zu tun,

738
00:53:07,020 --> 00:53:09,677
falls das wahr ist.
Und was ich hier mache ist X zu negieren.

739
00:53:10,002 --> 00:53:14,063
Der Negationsoperator, also, das
Minuszeichen in LISP ist ein wenig komisch.

740
00:53:14,492 --> 00:53:17,607
Wenn es zwei oder mehr Argumente sind...

741
00:53:18,007 --> 00:53:21,411
Wenn es zwei Argumente sind, dann
subtrahiert es das zweite vom ersten.

742
00:53:21,781 --> 00:53:23,996
Das haben wir gesehen. Und wenn es
ein Argument gibt, dann negiert es es.

743
00:53:25,025 --> 00:53:27,297
Das entspricht dem dort.

744
00:53:27,686 --> 00:53:32,833
Und es gibt einen anderen Fall. Er
sagt, im Fall, dass X gleich Null ist,

745
00:53:34,458 --> 00:53:36,835
ist die Antwort Null.

746
00:53:37,584 --> 00:53:44,684
Und im Fall, wo X
größer als Null ist, ist die Anwort X.

747
00:53:45,419 --> 00:53:49,090
Schließe den Fall, schließe das cond,
schließe die Definition.

748
00:53:49,543 --> 00:53:50,772
Da ist eine Definition des Betrags

749
00:53:51,173 --> 00:53:52,511
und Sie sehen dass es eine Fallzerlegung ist,

750
00:53:52,868 --> 00:53:55,881
die der Fallzerlegung, die man
in der Mathematik verwendet, sehr ähnelt.

751
00:53:57,685 --> 00:54:02,847
OK. Es gibt eine etwas unterschiedlichen Art,
eine eingeschränkte Fallzerlegung zu schreiben.

752
00:54:03,104 --> 00:54:06,421
Oft hat man eine Fallzerlegung
mit nur einem Fall.

753
00:54:06,905 --> 00:54:08,304
Oder man prüft etwas und

754
00:54:08,651 --> 00:54:10,767
abhängig davon, ob
es wahr oder falsch ist, macht man etwas.

755
00:54:13,020 --> 00:54:17,115
Hier ist eine andere Definition des Betrags,
die fast gleich aussieht,

756
00:54:17,774 --> 00:54:22,707
die besagt, wenn X kleiner als Null ist,
ist die Antwort negiere X,

757
00:54:24,321 --> 00:54:25,823
sonst ist die Antwort X.

758
00:54:26,214 --> 00:54:30,086
Wir werden IF oft verwenden. Aber nochmals,
was man sich merken sollte ist, dass diese Form

759
00:54:30,487 --> 00:54:32,695
des Betrags,
die Sie hier sehen,

760
00:54:34,004 --> 00:54:36,945
und dann diese hier drüben,
die ich auf die Tafel geschrieben habe,

761
00:54:37,486 --> 00:54:38,846
im Wesentlichen gleich sind.

762
00:54:39,140 --> 00:54:41,747
Und IF und COND sind
wie sie auch immer es mögen.

763
00:54:42,048 --> 00:54:44,352
Sie können sich COND
als syntaktischer Zucker für IF vorstellen,

764
00:54:44,933 --> 00:54:46,819
oder IF
als syntaktischer Zucker für COND,

765
00:54:47,267 --> 00:54:48,670
und es ist vollkommen egal.

766
00:54:49,157 --> 00:54:51,032
Die Person, die
a LISP system will pick one,

767
00:54:51,333 --> 00:54:52,773
und die andere in Form dieser implementieren,

768
00:54:53,116 --> 00:54:55,054
und es ist egal, welche sie ausgesucht hat.

769
00:55:02,534 --> 00:55:04,978
OK. Warum machen wir jetzt nicht eine Pause
und beantworten dann ein paar Fragen.

770
00:55:05,572 --> 00:55:07,213
Wie kommt es...

771
00:55:08,079 --> 00:55:10,443
manchmal wenn ich define schreibe

772
00:55:11,118 --> 00:55:13,236
mache ich hier eine öffnende Klammer

773
00:55:14,181 --> 00:55:16,404
und sage define, Klammer-auf,
irgendein Ding,

774
00:55:16,794 --> 00:55:20,907
und manchmal wenn ich das schreibe,
mache ich keine öffnende Klammer?

775
00:55:22,225 --> 00:55:24,354
OK. Die Antwort ist...

776
00:55:25,298 --> 00:55:29,044
diese besondere Form von define,
wo man sagt definiere einen Ausdruck

777
00:55:29,563 --> 00:55:32,267
ist etwas sehr spezielles,
um Prozeduren zu definieren.

778
00:55:33,470 --> 00:55:40,727
But again, what it really means is I'm
definiere dieses Symbol square als das.

779
00:55:41,290 --> 00:55:45,942
Also, Sie sollten so darüber nachdenken,
was macht define wenn man define schreibt,

780
00:55:47,034 --> 00:55:49,709
und als Zweites schreibt man
dieses Symbol hier, keine Klammer auf,

781
00:55:50,199 --> 00:55:51,653
dieses Symbol, das man definiert.

782
00:55:52,111 --> 00:55:57,182
Und als was man es definiert...
das ist wie hier... und wie hier...

783
00:55:57,586 --> 00:56:00,578
Das ist die
grundlegende Art, wie man define benutzt

784
00:56:01,094 --> 00:56:03,556
und dann gibt es
den speziellen syntaktischen Trick,

785
00:56:04,214 --> 00:56:07,399
der einem ermöglicht,
Prozeduren, die so aussehen, zu definieren.

786
00:56:08,032 --> 00:56:14,746
Also, der Unterschied ist, ob
man eine Prozedur definiert oder nicht.

787
00:56:38,089 --> 00:56:42,058
Also, glauben Sie es oder nicht,
Sie wissen jetzt eigentlich genug LISP

788
00:56:42,700 --> 00:56:45,402
um im Wesentlichen
jede numerische Prozedur zu schreiben,

789
00:56:46,039 --> 00:56:49,115
die Sie in einer Sprache
wie Fortran oder Basic oder so,

790
00:56:49,555 --> 00:56:51,241
or essentially any other language.

791
00:56:52,034 --> 00:56:54,681
Sie denken wahrscheinlich
dass das unglaublich ist, oder?

792
00:56:55,028 --> 00:56:57,785
Denn Sie wissen, dass diese Sprachen
Sachen wie Laufanweisungen (for statement)

793
00:56:58,239 --> 00:57:00,397
und do...until/while oder sowas haben.

794
00:57:00,950 --> 00:57:04,795
Aber wir brauchen das alles nicht wirklich.

795
00:57:05,158 --> 00:57:07,151
Wir werden das alles
in diesem Kurs nicht verwenden.

796
00:57:08,192 --> 00:57:12,935
Ich zeige das
und betrachte die Quadratwurzel nochmal.

797
00:57:13,336 --> 00:57:16,124
Gehen wir zurück zu diesem
Quadratwurzelalgorithmus

798
00:57:17,188 --> 00:57:19,531
von Heron von Alexandria.
Erinnern Sie sich, was der aussagte?

799
00:57:19,983 --> 00:57:26,589
Er sagt, um eine Abschätzung der
Quadratwurzel von X zu finden, macht man eine Schätzung (guess),

800
00:57:27,307 --> 00:57:32,022
und man verbessert (improve) diese Schätzung durch das Mitteln
der Schätzung und X geteilt durch die Schätzung,

801
00:57:32,754 --> 00:57:35,993
man verbessert das weiter,
bis die Schätzung gut genug ist.

802
00:57:36,590 --> 00:57:38,177
Und ich habe die Idee bereits angedeutet.

803
00:57:38,517 --> 00:57:42,235
Die Idee ist, dass
wenn die erste Schätzung, die sie gemacht hat...

804
00:57:42,972 --> 00:57:46,702
wenn diese anfängliche Schätzung tatsächlich
gleich der Quadratwurzel von X wäre,

805
00:57:47,117 --> 00:57:50,634
dann wäre das G hier gleich X geteilt durch G.

806
00:57:52,762 --> 00:57:55,159
Also wenn man die Quadratwurzel getroffen hat,
würde sie mitteln nicht ändern.

807
00:57:55,560 --> 00:57:59,865
Wenn das G, das man gewählt hat, größer
als die Quadratwurzel von X wäre,

808
00:58:00,255 --> 00:58:02,573
dann wäre X/G kleiner
als die Quadratwurzel von X,

809
00:58:03,122 --> 00:58:07,574
so dass, wenn man G und X/G mittelt,
etwas dazwischen bekommt.

810
00:58:08,945 --> 00:58:12,663
Oder? Also, Sie ein G wählen das zu
klein ist, wird Ihre Antwort zu groß sein.

811
00:58:13,074 --> 00:58:14,954
Wenn man ein zu großes G wählt...

812
00:58:16,192 --> 00:58:18,889
if your G is larger than the square
Quadratwurzel von X dann wird X/G kleiner sein

813
00:58:19,190 --> 00:58:20,653
als die Quadratwurzel von X.

814
00:58:21,090 --> 00:58:23,801
Also, Mitteln gibt einem immer
etwas dazwischen,

815
00:58:24,302 --> 00:58:28,587
und es ist dann nicht so trivial,
aber es ist möglich, dass tatsächlich,

816
00:58:29,263 --> 00:58:31,255
wenn G
die Quadratwurzel von X ein bisschen verfehlt,

817
00:58:31,682 --> 00:58:35,599
wird das Mittel von G und X/G
in der Tat immer näher

818
00:58:36,682 --> 00:58:38,923
gegen die Quadratwurzel von X konvergieren.
Also, wenn man das genug lange macht,

819
00:58:39,350 --> 00:58:42,657
wird man schließlich so nah
as you want. And there's another fact

820
00:58:42,958 --> 00:58:47,635
dass man diesen Prozess immer
mit 1 als Anfangsschätzung beginnen kann,

821
00:58:49,168 --> 00:58:51,498
und es wird immer
gegen die Quadratwurzel von X konvergieren.

822
00:58:52,107 --> 00:58:56,297
Oder? Also, das ist die Methode des aufeinanderfolgenden
Mittelns von Heron von Alexandria.

823
00:58:56,620 --> 00:58:59,311
Schreiben wir das in LISP.

824
00:58:59,812 --> 00:59:03,363
Nun, der zentrale Gedanke ist,

825
00:59:03,912 --> 00:59:07,463
was heisst es eine Schätzung auszuprobieren
für die Quadratwurzel von X?

826
00:59:08,295 --> 00:59:10,672
Schreiben wir das. Also wir sagen

827
00:59:11,495 --> 00:59:13,624
define...

828
00:59:15,292 --> 00:59:21,469
um auszuprobieren (try) eine Schätzung (guess)

829
00:59:23,227 --> 00:59:25,296
für die Quadratwurzel von X.

830
00:59:26,152 --> 00:59:33,059
Was machen wir?
Wir sagen, wenn (if) die Schätzung gut genug ist...

831
00:59:38,539 --> 00:59:45,199
Wenn die Schätzung gut genug (good-enough) ist,
um eine Abschätzung (guess) der Quadratwurzel von X zu sein,

832
00:59:46,375 --> 00:59:50,952
dann nehmen wir die Schätzung als Antwort.

833
00:59:51,536 --> 00:59:57,016
Sonst probieren (try) wir die verbesserte (improve) Schätzung.

834
00:59:58,565 --> 01:00:02,163
Wir werden die Schätzung

835
01:00:02,772 --> 01:00:04,671
für die Quadratwurzel von X verbessern,

836
01:00:05,176 --> 01:00:09,081
und das
als Schätzung für die Quadratwurzel von X ausprobieren.

837
01:00:09,440 --> 01:00:12,732
... schließe den Versuch,
schließe das if, schließe das define.

838
01:00:13,255 --> 01:00:15,029
Also, so probieren wir eine Schätzung aus.

839
01:00:15,641 --> 01:00:19,762
Und der nächste Teil des Prozesses
war, um Quadratwurzeln zu berechnen,

840
01:00:21,192 --> 01:00:23,789
sagen wir define

841
01:00:25,539 --> 01:00:29,927
um die Quadratwurzel (sqrt) von X zu berechnen,

842
01:00:30,328 --> 01:00:36,187
probieren (try) wir 1 als Abschätzung
für die Quadratwurzel von X.

843
01:00:37,545 --> 01:00:39,405
Nun, wir müssen
paar andere Dinge definieren.

844
01:00:40,019 --> 01:00:45,379
Nun, wir müssen sagen, wann ist eine Schätzung gut
genug und wie verbessern wir eine Schätzung.

845
01:00:45,803 --> 01:00:49,532
Also schauen wir uns das an.
Der Algorithmus zum Verbessern der Schätzung

846
01:00:50,178 --> 01:00:55,813
Oder? Um eine Schätzung 
für die Quadratwurzel von X zu verbessern, mitteln wir...

847
01:00:56,275 --> 01:00:58,359
So ging der Algorithmus...
Wir mitteln die Schätzung

848
01:00:58,818 --> 01:01:04,354
mit dem Quotienten von X geteilt durch
die Schätzung. So verbessern wir die Schätzung.

849
01:01:05,678 --> 01:01:08,366
Und um festzustellen, ob eine Schätzung gut
genug ist, müssen wir etwas entscheiden.

850
01:01:08,783 --> 01:01:11,018
Das soll eine Schätzung sein
für die Quadratwurzel von X.

851
01:01:11,319 --> 01:01:12,923
Also eine Möglichkeit

852
01:01:13,281 --> 01:01:15,876
ist, wenn man
diese Schätzung quadriert,

853
01:01:16,627 --> 01:01:18,181
bekommt man etwas sehr nahe an X?

854
01:01:18,582 --> 01:01:22,232
Zum Beispiel eine Art das zu sagen,
ist zu sagen, ich quadriere die Schätzung,

855
01:01:22,835 --> 01:01:27,464
ziehe X von dem ab und schaue, ob
der Betrag von dem ganzen

856
01:01:27,865 --> 01:01:29,658
weniger als irgendeine kleine Zahl ist,

857
01:01:30,449 --> 01:01:32,622
die von meinen Absichten abhängt.

858
01:01:34,750 --> 01:01:36,282
OK. Also hier ist eine...

859
01:01:37,545 --> 01:01:40,912
hier ist eine vollständige Prozedur
wie man die Quadratwurzel von X berechnet.

860
01:01:41,362 --> 01:01:44,347
Sehen wir uns
die Struktur davon ein bisschen an.

861
01:01:48,402 --> 01:01:55,073
Ich habe das ganze. Ich habe den
Begriff wie man eine Quadratwurzel berechnet.

862
01:01:55,474 --> 01:01:58,249
Das ist eine Art Modul.
Oder? Das ist eine Art black box.

863
01:01:58,667 --> 01:02:01,964
Sie ist definiert als...

864
01:02:03,816 --> 01:02:08,217
Sie ist definiert mittels: wie man
eine Schätzung für die Quadratwurzel von X ausprobiert.

865
01:02:09,223 --> 01:02:15,840
Ausprobieren (try) ist definiert mittels, nun,
zu sagen ob etwas gut genug ist (good-enough),

866
01:02:16,241 --> 01:02:18,277
und zu sagen, wie man etwas verbessert (improve).

867
01:02:18,678 --> 01:02:24,139
Also good enough...
Ausprobieren ist definiert mittels good-enough (gut genug)?

868
01:02:25,397 --> 01:02:29,459
und verbessern.

869
01:02:30,745 --> 01:02:32,328
Und (sehen wir was ich sonst eintrage)...

870
01:02:32,726 --> 01:02:34,052
Wenn man diesen Baum runtergeht

871
01:02:34,610 --> 01:02:38,568
good-enough? war definiert
mittels absolutem Betrag und square.

872
01:02:40,642 --> 01:02:44,556
Und improve war definiert
mittels etwas genannt mitteln (average)

873
01:02:45,028 --> 01:02:46,637
und noch paar anderen primitiven Operatoren.

874
01:02:47,427 --> 01:02:50,867
Quadratwurzel ist definiert mittels try.
Ausprobieren ist definiert mittels good-enough (gut genug)?

875
01:02:52,072 --> 01:02:55,066
und improve, aber auch try selbst.

876
01:02:55,467 --> 01:03:01,075
try ist also auch selbst definiert
mittels wie man ausprobiert (try).

877
01:03:02,713 --> 01:03:04,457
Naja, das könnte ein Problem geben.

878
01:03:04,975 --> 01:03:09,825
Ihr High School Geometrielehrer
hat Ihnen wahrscheinlich erzählt es sei unartig,

879
01:03:10,226 --> 01:03:13,324
etwas definieren zu wollen mit
sich selbst, weil das weder Hand noch Fuß hat.

880
01:03:13,725 --> 01:03:15,442
Aber das ist falsch.

881
01:03:16,503 --> 01:03:19,734
Manchmal ist es komplett sinnvoll,
Sachen mit sich selbst zu definieren.

882
01:03:20,260 --> 01:03:22,615
Und das ist der Fall.

883
01:03:23,210 --> 01:03:25,756
Und wir können das betrachten,
wir können aufschreiben, was das bedeutet

884
01:03:26,222 --> 01:03:30,577
Sagen wir einmal, ich frage LISP, 
was die Quadratwurzel von 2 ist.

885
01:03:32,572 --> 01:03:34,739
Nun, was
bedeutet die Quadratwurzel von 2?

886
01:03:35,651 --> 01:03:44,096
Also, das heisst ich probiere (try) 1
als Schätzung für die Quadratwurzel von 2.

887
01:03:46,731 --> 01:03:50,935
Nun, ich schaue, ich sage nanu, ist die Schätzung 1 gut
genug für die Quadratwurzel von 2?

888
01:03:51,655 --> 01:03:54,160
Das hängt ab vom Test,
den good-enough macht.

889
01:03:54,562 --> 01:03:56,347
Und in diesem Fall
das good-enough wird nein sagen,

890
01:03:56,701 --> 01:03:59,061
die Schätzung 1 ist nicht gut genug
für die Quadratwurzel von 2.

891
01:03:59,584 --> 01:04:01,366
Also, das wird zurückgeführt auf folgendes:

892
01:04:01,650 --> 01:04:04,910
Ich muss probieren (try)

893
01:04:06,818 --> 01:04:12,990
das verbesserte (improve) und verbesserte... improve 1
als Schätzung für die Quadratwurzel von 2

894
01:04:14,882 --> 01:04:17,860
und das als Schätzung ausprobieren
für die Quadratwurzel von 2.

895
01:04:18,931 --> 01:04:25,731
1 zu verbessern als Schätzung für die
Quadratwurzel von 2 bedeutet, ich mittle 1 und 2/1.

896
01:04:26,980 --> 01:04:28,884
So, das wird das Mittel...

897
01:04:29,464 --> 01:04:39,933
dieses Stück hier wird das Mittel
von 1 und dem Quotienten von 2 durch 1.

898
01:04:40,883 --> 01:04:42,874
So, dieses Stück hier.

899
01:04:43,848 --> 01:04:47,457
Und ich werde versuchen (try)... Und das ist 1.5...

900
01:04:49,010 --> 01:04:54,122
Also, diese Quadratwurzel von 2 wird reduziert
auf 1 zu versuchen für die Quadratwurzel von 2,

901
01:04:54,588 --> 01:05:02,200
was reduziert wird darauf, 1.5 zu versuchen

902
01:05:03,115 --> 01:05:05,592
als Schätzung für die Quadratwurzel von 2.

903
01:05:06,032 --> 01:05:09,145
Oder? Also das ergibt Sinn.
Sehen wir uns den Rest des Prozesses an.

904
01:05:09,538 --> 01:05:14,430
Hier, wenn ich 1.5 probiere, das reduziert sich...

905
01:05:14,831 --> 01:05:19,065
1,5 fällt nicht gut genug aus
als Schätzung für die Quadratwurzel von 2.

906
01:05:19,879 --> 01:05:23,797
Also, das reduziert sich auf das Ausprobieren
des Mittels von 1,5 und 2/1,5

907
01:05:24,198 --> 01:05:26,561
als Schätzung für die Quadratwurzel von 2.

908
01:05:28,127 --> 01:05:30,275
Das Mittel stellt sich als 1,3333 heraus,

909
01:05:30,959 --> 01:05:33,748
Also reduziert sich das ganze Ding
auf das Ausprobieren von 1,3333 als Schätzung

910
01:05:34,149 --> 01:05:36,224
für die Quadratwurzel von 2, und immer so weiter.

911
01:05:37,298 --> 01:05:39,719
Oder? Das wird reduziert
auf einen weiteren Aufruf von good-enough.

912
01:05:40,095 --> 01:05:45,812
1.4xxx und dann macht es so weiter bis der
Prozess schließlich stoppt mit etwas, von dem

913
01:05:46,177 --> 01:05:51,371
good-enough denkt, dass es gut genug ist,
was in diesem Fall 1,4142xxx ist.

914
01:05:52,366 --> 01:05:56,515
Also ist der Prozess vollkommen sinnvoll.

915
01:05:59,353 --> 01:06:06,366
Nebenbei, das
is called a recursive definition.

916
01:06:13,928 --> 01:06:18,623
Und die Möglichkeit,
rekursive Definitionen zu machen

917
01:06:19,251 --> 01:06:20,823
ist eine Quelle unglaublicher Macht.

918
01:06:21,721 --> 01:06:23,653
Ich habe hingewiesen, dass das es

919
01:06:24,249 --> 01:06:27,252
einem möglich macht, um
diese unendlichen Berechnungen zu machen, die weitergehen,

920
01:06:27,653 --> 01:06:29,296
bis etwas wahr ist.

921
01:06:29,621 --> 01:06:33,741
Ohne andere Konstrukte, ausser
die Möglichkeit, eine Prozedur aufzurufen.

922
01:06:35,338 --> 01:06:38,979
Stellen wir fest, da ist noch
etwas. Lassen Sie mich Ihnen eine Variante

923
01:06:39,463 --> 01:06:41,317
dieser Definition der Quadratwurzel zeigen.

924
01:06:43,119 --> 01:06:47,889
Sehen Sie auf die Folie hier. Hier ist...
Hier ist ungefähr dasselbe.

925
01:06:48,248 --> 01:06:50,195
Hier habe ich

926
01:06:50,609 --> 01:06:55,858
die Definitionen von improve und
good-enough und try in sqrt (Quadratwurzel) verpackt.

927
01:06:56,639 --> 01:07:00,669
So in effect what I've done
is I've built a square root box.

928
01:07:01,746 --> 01:07:07,769
I've built a box. That's this square root
die jemand verwenden kann.

929
01:07:08,170 --> 01:07:11,423
Sie könnten 36 eingeben und 6 rausbekommen.

930
01:07:11,833 --> 01:07:13,696
Und dann habe ich in dieser Box verpackt,

931
01:07:14,131 --> 01:07:24,247
die Definitionen von try,
und good-enough, und improve.

932
01:07:26,845 --> 01:07:30,583
So they're hidden inside this box.
And the reason for doing that is that

933
01:07:31,104 --> 01:07:33,000
wenn jemand dieses sqrt verwendet...

934
01:07:33,360 --> 01:07:36,464
wenn Georg dieses sqrt verwendet,
ist es Georg wahrscheinlich ziemlich egal,

935
01:07:36,905 --> 01:07:39,545
dass bei der Implementation der Quadratwurzel

936
01:07:40,058 --> 01:07:44,870
diese Sachen dort drin sind,
genannt try und good-enough und improve.

937
01:07:46,018 --> 01:07:48,704
Und in der Tat, könnte Harry
eine Kubikwurzelprozedur haben,

938
01:07:49,105 --> 01:07:50,898
die try und good-enough und improve hat.

939
01:07:51,257 --> 01:07:53,672
Und um das ganze System nicht
zu verwirren wird es für Harry gut sein,

940
01:07:54,073 --> 01:07:57,824
seine internen Prozeduren
innerhalb seiner Kubikwurzelprozedur zu verpacken.

941
01:07:58,272 --> 01:08:03,133
Das wird Blockstruktur genannt.
Diese spezielle Art,

942
01:08:05,583 --> 01:08:09,047
Einbauten innerhalb einer Definition zu verpacken.

943
01:08:09,692 --> 01:08:13,968
Und gehen wir nochmal zurück und sehen diese
Folie nochmal an. Wie man das liest,

944
01:08:14,412 --> 01:08:18,641
diese Art von Prozedur, ist
zu sagen, define sqrt (Quadratwurzel)...

945
01:08:19,793 --> 01:08:21,553
naja, innerhalb dieser Definition

946
01:08:22,015 --> 01:08:24,423
habe ich die Definition von improve,

947
01:08:24,926 --> 01:08:29,259
und die Definition von good-enough,
und die Definition von try.

948
01:08:29,685 --> 01:08:35,393
Und diesen Definitionen,
wie ich die Quadratwurzel ziehe, liegt das ausprobieren (try) von 1 zugrunde.

949
01:08:35,983 --> 01:08:39,189
Und beachten Sie, hier muß ich nicht
1 als Schätzung für die Quadratwurzel von X angeben.

950
01:08:39,767 --> 01:08:44,462
Denn weil es alles innerhalb dieser
Quadratwurzel ist, hat es dieses X jetzt.

951
01:08:54,223 --> 01:08:56,105
OK. Nun, lassen Sie mich zusammenfassen.

952
01:08:56,506 --> 01:08:58,623
Wir haben angefangen mit der Idee,

953
01:08:59,003 --> 01:09:03,562
dass was wir machen,
ist imperatives Wissen auszudrücken.

954
01:09:04,965 --> 01:09:09,319
Und tatsächlich ist hier eine Folie, die
zusammenfaßt, wie wir LISP untersucht haben.

955
01:09:09,700 --> 01:09:12,880
Wir haben angefangen,
uns einige primitive Elemente anzusehen:

956
01:09:13,432 --> 01:09:15,323
Addition, Multiplikation,

957
01:09:15,796 --> 01:09:19,266
einige Prädikate zum Testen ob
etwas weniger ist oder etwas gleich ist

958
01:09:19,567 --> 01:09:21,110
und in der Tat haben wir wirklich schnell festgestellt,

959
01:09:21,588 --> 01:09:24,517
dass in diesem System, das wir verwenden,
diese gar keine Primitive sind,

960
01:09:24,900 --> 01:09:26,208
aber es macht nichts aus.

961
01:09:26,509 --> 01:09:28,186
Was eine Rolle spielt, ist dass 
wir sie verwenden, als ob sie Primitive sind,

962
01:09:28,587 --> 01:09:29,922
wir werden nicht rein schauen.

963
01:09:30,223 --> 01:09:33,420
Wir haben auch
einige primitiven Daten... einige Zahlen.

964
01:09:34,071 --> 01:09:39,128
Wir haben paar Mittel zum Zusammensetzen,
Mittel zur Kombination gesehen, die grundlegende ist

965
01:09:39,816 --> 01:09:44,379
Funktionen zusammenzusetzen und
Kombinationen zu bauen mit Operatoren und Operanden.

966
01:09:44,796 --> 01:09:49,127
Und es gibt paar andere Dinge
wie COND und IF und DEFINE.

967
01:09:51,099 --> 01:09:53,317
Aber die Hauptsache
über define im speziellen

968
01:09:53,735 --> 01:09:57,151
war, dass es das Abstraktionsmittel war,
wie wir Sachen benennen.

969
01:09:57,552 --> 01:09:59,603
Sie können auch an dieser Folie sehen,
nicht nur wo wir gewesen sind,

970
01:10:00,004 --> 01:10:01,917
sondern die Lücken die wir auffüllen müssen.
Irgendwann

971
01:10:02,339 --> 01:10:05,980
müssen wir daüber sprechen, wie man
primitive Daten kombiniert, um zusammengesetzte Daten zu bekommen,

972
01:10:06,398 --> 01:10:08,059
und wie man Daten abstrahiert,

973
01:10:08,518 --> 01:10:13,371
so dass man große
Datenbrocken verwenden kann wie primitve.

974
01:10:13,905 --> 01:10:15,839
Das ist also, was wir machen werden.

975
01:10:16,315 --> 01:10:22,403
Aber bevor wir das machen in den nächsten paar
Lektionen, werden wir zuerst darüber reden,

976
01:10:23,156 --> 01:10:28,148
wie man eine
Verbindung zwischen diesen Prozeduren, die wir schreiben, schafft,

977
01:10:28,633 --> 01:10:31,167
und den Prozeduren,
die in der Maschine stattfinden.

978
01:10:31,973 --> 01:10:33,629
Und dann, wie

979
01:10:34,030 --> 01:10:35,735
fängt man an, die Mächtigkeit von LISP zu verwenden,

980
01:10:36,291 --> 01:10:39,449
um nicht nur über
diese einzelnen kleinen Berechnungen

981
01:10:39,850 --> 01:10:44,449
sondern über allgemeine
konventionelle Methoden, etwas zu tun, zu sprechen.

982
01:10:44,974 --> 01:10:46,475
OK. Gibt es irgendwelche Fragen?

983
01:10:46,804 --> 01:10:50,411
- Ja. Wenn wir A mit Klammern definiert hätten

984
01:10:50,810 --> 01:10:53,030
anstatt wie wir es gemacht haben,
was wäre der Unterschied?

985
01:10:53,391 --> 01:10:55,099
- Wenn ich das schrieben hätte...

986
01:10:55,752 --> 01:11:02,669
Wenn ich das geschrieben hätte, hätte ich
eine Prozedur namens A definiert,

987
01:11:03,098 --> 01:11:04,997
in diesem Fall eine Prozedur ohne Argumente,

988
01:11:06,302 --> 01:11:10,339
die mir, wenn ich sie ausführen würde,
5 mal 5 zurückgeben würde.

989
01:11:10,696 --> 01:11:13,453
- Man kommt also auf dasselbe,
ausser dass man wirklich eine unterschiedliche...

990
01:11:13,809 --> 01:11:14,734
- Korrekt. Und der Unterschied...

991
01:11:15,147 --> 01:11:18,615
the difference would be in the old one...
Let me be a little bit clearer here...

992
01:11:20,089 --> 01:11:23,748
Nennen wir das A wie hier.

993
01:11:24,112 --> 01:11:26,305
Tun Sie hier zum Unterschied so, als ob

994
01:11:27,113 --> 01:11:29,528
ich geschrieben hätte define...

995
01:11:30,604 --> 01:11:37,818
(D) to be the product of 5 and 5.

996
01:11:39,695 --> 01:11:41,413
Und der Unterschied zwischen diesen beiden.

997
01:11:41,865 --> 01:11:44,427
Denken wir über Interaktionen
mit dem LISP-Interpreter nach.

998
01:11:45,561 --> 01:11:49,357
Ich würde A eintippen
und LISP würde 25 zurückgeben.

999
01:11:52,852 --> 01:11:59,527
Ich könnte D eintippen...
wenn ich nur D eintippe, würde LISP

1000
01:12:01,144 --> 01:12:06,569
compound procedure D (zusammengesetzte Prozedur D) zurückgeben. 

1001
01:12:07,345 --> 01:12:09,027
Denn das ist es,
es ist eine Prozedur.

1002
01:12:09,524 --> 01:12:12,110
Ich könnte D ausfürhren. Ich könnte sagen,
was ist der Wert nach Ausführen von D?

1003
01:12:12,511 --> 01:12:15,247
Hier ist eine Kombination ohne Operanden.

1004
01:12:16,464 --> 01:12:18,757
Und ich sehe, dass da keine Operanden sind.
Ich habe nach D keine hingeschrieben.

1005
01:12:19,360 --> 01:12:21,507
Und ich würde sagen oh, das ist 25.

1006
01:12:23,100 --> 01:12:26,550
Oder ich könnte sage... nur zur Vollständigkeit,

1007
01:12:26,951 --> 01:12:30,357
wenn ich eingegeben hätte, was
ist der Wert nach Ausführen von A, bekomme ich einen Fehler.

1008
01:12:31,481 --> 01:12:35,117
Der Fehler wäre
derselbe wie dort drüben.

1009
01:12:35,520 --> 01:12:39,032
Der Fehler wäre, Entschuldigung, 25,

1010
01:12:39,460 --> 01:12:43,703
das ist der Wert von A, ist kein
Operator, den ich auf etwas anwenden kann.

1011
01:12:45,041 --> 01:12:46,274
OK.

1012
01:12:47,213 --> 01:12:52,857
Englische Untertitel erstellt von Sergey Khenkin, ins dt. übersetzt von Toni Moll
http://www.sicptitles.org, http://code.google.com/p/sicp-subtitles

